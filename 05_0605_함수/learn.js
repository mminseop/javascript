// 1. 목표 : 함수 선언문을 사용하여 함수를 정의하고, 함수 정의에 필요한 요소(함수명, 매개변수, 함수 본문)를 모두 나열할 수 있다.

// 함수란? 함수는 코드 덩어리에 이름을 붙여놓은 것
// 1. 함수 이름 – 무엇을 하는 함수인지 나타냅니다
// 2. 매개변수(parameter) – 필요한 데이터를 받아오기 위한 이름표입니다
// 3. 함수 본문(body) – 함수가 실제로 실행할 코드가 담겨 있습니다


// ㅇ 함수 선언문의 구성요소
function add(x, y) {
    return x + y;
}
add(2, 5);

// 1. function 키워드
// - 함수 선언문은 항상 `function` 키워드로 시작합니다.
// - JavaScript에 “지금부터 함수를 정의한다”는 것을 알리는 예약어입니다

// 2. 함수명 (function name)
// - 함수를 구분하고 호출하기 위한 이름입니다.
// - 변수명과 동일한 네이밍 규칙을 따르며, 'camelCase 표기법'을 사용하는 것이 일반적입니다.
// - JavaScript의 예약어(`function`, `return`, `const` 등)는 사용할 수 없습니다. (참고 문서: [MDN-JavaScript 예약어](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#reserved_words))
// - 함수의 목적이나 기능이 드러나는 이름을 사용해야 코드를 읽기 쉽습니다.
//     예시: `calculateSum`, `printMessage`, `getUserInfo`

// 3. 매개변수 (parameter)
// - 함수 정의 시 소괄호 `()` 안에 작성되는 변수들로, '함수 외부에서 전달받는 값을 내부에서 사용할 수 있게 해줍니다.'
// - 매개변수의 개수는 제한이 없으며, 쉼표로 구분합니다.
// - 함수 내부에서는 일반 변수처럼 사용할 수 있습니다.

// 4. 함수 본문 (function body)
// - 중괄호 `{}` 안에 작성되는 코드 블록입니다.
// - 함수가 호출되었을 때 실행될 작업을 이 안에 작성합니다.

// 5. ** return문
// - 함수 실행 결과를 함수 외부로 반환할 때 사용합니다.
// - `return`문 뒤에 있는 값이 함수의 최종 결과값으로 반환됩니다.
// - `return`문이 실행되면 함수는 즉시 종료되며, 이후의 코드는 실행되지 않습니다.
// - `return`문을 생략하거나 반환값이 없는 경우, `undefined`가 자동 반환됩니다.

// 변수 answer를 선언하고, 함수 add에 2, 5를 전달하여 나온 반환값을 할당
let answer = add(2, 5);
// 함수 본문에 의해 x + y가 2 + 5로 계산되어 7을 출력
console.log(answer);
// ** return문은 "함수의 결과값을 외부로 보내는 문장"이라고 생각하면 이해하기 쉽습니다. 함수 내부에서 어떤 작업을 하고 그 결과를 다른 코드에서 활용하려면 반드시 return이 필요합니다.

// ### ⚠️ 함수 선언문으로 함수를 정의할 때 주의 사항
// 1. '`function` 키워드는 반드시 소문자로 작성해야 합니다'
//     - 대소문자를 구분하므로 `Function`, `FUNCTION`처럼 작성하면 오류가 발생합니다.
// 2. '함수명은 camelCase로 작성하고 예약어를 피해야 합니다'
//     - 예: `calculateSum`, `getUserInfo`처럼 동작을 명확히 표현하고, `let`, `return`, `function` 등의 예약어는 사용하지 않아야 합니다.
// 3. '함수명만으로는 함수가 실행되지 않습니다'
//     - 함수는 정의만으로는 실행되지 않으며, 별도로 호출해야 동작합니다.
// 4. '매개변수는 필요 없을 수도 있고, 여러 개가 될 수도 있습니다'
//     - 매개변수가 없는 경우 소괄호만 작성합니다: `function greet() { ... }`
//     - 매개변수가 많을 때는 쉼표로 구분합니다: `function sum(a, b, c) { ... }`
// 5. '`return`문을 만나면 함수는 즉시 종료됩니다'
//     - `return` 아래의 코드는 실행되지 않으므로, 불필요한 코드가 작성되지 않도록 주의해야 합니다.


// '함수 선언문은 JavaScript에서 가장 기본적인 함수 정의 방법입니다.' 

// `function` 키워드, 함수명, 매개변수, 함수 본문, 그리고 `return`문까지 각 요소의 역할을 정확히 이해하면 함수 작성이 쉬워집니다. 이제 여러분은 코드의 반복을 줄이고, 재사용성과 유지보수성을 높이는 강력한 도구인 "함수"를 제대로 사용할 준비가 되어 있습니다!

// '특히 앞으로 배우게 될 React에서는 대부분의 컴포넌트를 함수 형태로 작성하므로, 함수에 대한 이해는 웹 개발을 이어나가는 데 매우 중요한 기초가 됩니다.'
// ==============================================================================================

// 2. 목표 : 함수 선언문을 함수 표현식으로 변경하고, 두 방식의 차이를 설명할 수 있다.

// '함수를 정의하는 방법에는 두 가지 방식이 있다는 사실, 알고 있었나요?'

// JavaScript에서는 `function` 키워드를 사용한 '함수 선언문' 외에도, 함수를 값처럼 변수에 할당하는 '함수 표현식'을 사용할 수 있습니다.

// 두 방식은 모양은 비슷하지만 '동작 시점과 활용 방식에서 중요한 차이점'이 존재합니다.

// '함수 표현식은 코드 실행 흐름에 따라 더 유연하게 활용될 수 있고, 이후 배울 화살표 함수(Arrow Function)의 기반이 되기도 하므로, 두 방식을 비교해보며 차이를 정확히 이해해두면 좋아요.'


// ㅇ 일급 객체
// - JavaScript에서 함수는 일급 객체(first-class citizen)로 취급됩니다. 즉, 함수도 숫자나 문자열처럼 하나의 값처럼 다룰 수 있습니다. 이러한 특징 덕분에 함수를 변수에 저장하거나, 다른 함수의 인자로 전달하거나, 다른 함수의 결과값으로 반환하는 것이 가능합니다. 이를 활용한 대표적인 개념이 각각 함수 표현식, 콜백 함수, 클로저입니다. (함수도 값처럼 다룰 수 있다는 사실이 처음엔 낯설게 느껴질 수 있지만, JavaScript에서 매우 기본적이고 강력한 기능 중 하나입니다.)
// - 함수 표현식 => 함수를 변수에 저장 - 함수를 하나의 값처럼 변수에 저장하여 호출
// - 콜백 함수 => 함수를 인자로 전달 - 다른 함수 안에서 실행될 함수를 전달
// - 클로저 => 함수를 반환값으로 사용 - 함수를 실행한 결과로 또 다른 함수를 반환


// ✅ 함수 표현식(Function Expression)
// 함수를 하나의 값처럼 변수에 할당하는 방식입니다. 
// 이 경우 함수의 이름이 아닌, 함수를 저장한 변수 이름으로 함수를 호출하게 됩니다. 

// ㅇ 함수 표현식의 형태
// let 변수명 = function 함수명 (매개변수) {
// 	return 반환값;
// }
// console.log(변수명(전달인자)); // 반환값
// console.log(함수명(전달인자)); // ReferenceError: 함수명 is not defined

// 예시
// let add2 = function addNum1Num2(num1, num2){
// 	return num1 + num2;
// }

// console.log(add2(2, 5)); // 7
// console.log(addNum1Num2(2, 5)); // Uncaught ReferenceError: addNum1Num2 is not defined

// ㅇ 함수명을 생략한 함수 표현식
// - 함수명을 생략하는 것이 일반적

// // 함수명을 생략하여 정의
// let 변수명 = function (매개변수) {
// 	return 반환값;
// }

// console.log(변수명(전달인자)); // 반환값

let addTest = function (x, y) {
    return x + y;
}
console.log(addTest(10, 10));


// ### ❓ 함수 선언문? 함수 표현식? 이름이 너무 헷갈려요!

// 함수 선언문은 '함수 선언 키워드인 function'을 직접 사용해 '함수를 선언'하기 때문에 '선언문(declaration)'이라고 부릅니다.

// 반면, 함수 표현식은 `let`, `const` 같은 '변수 선언 키워드'를 사용해 함수를 변수에 할당하여 '함수를 표현'하는 방식이기 때문에 '표현식(expression)'이라고 부릅니다.

// '👉 이름부터 함수가 어떻게 정의되는지 힌트를 주고 있는 셈입니다!'

// ==========================================================
// ### ✅ 함수 선언문보다 함수 표현식이 더 자주 권장되는 이유

// 함수 선언문과 함수 표현식은 상황에 따라 다르게 사용할 수 있지만, '현대 JavaScript에서는 함수 표현식을 더 자주 사용하고 권장'하는 경향이 있습니다. 그 이유는 다음과 같습니다.

// 1. '코드 흐름이 더 예측 가능하다'
//     함수 선언문은 코드 상단으로 끌어올려지는 '호이스팅' 현상이 발생합니다. 이로 인해 실제로 함수가 정의되기 전에 호출해도 작동합니다. 반면, '함수 표현식은 변수에 저장된 이후에만 사용 가능'하기 때문에, 함수 정의 위치와 호출 순서를 '보다 명확하게 파악할 수 있습니다'
        
// 2. '`const`와 함께 사용하면 안정성 증가'
//     함수 표현식은 `const`로 선언해두면 '의도치 않게 함수가 재할당되는 것을 방지'할 수 있어 더 안전한 코딩이 가능합니다.
    
// 3. '화살표 함수로 간결하게 확장 가능'
//     함수 표현식은 자연스럽게 '화살표 함수(arrow function)'로 변형할 수 있어, 코드가 더 간결해지고 최신 JavaScript 문법에 적합합니다. 특히 콜백 함수나 간단한 연산을 수행하는 함수에서는 화살표 함수가 큰 장점을 발휘합니다.

//     - '함수와 호이스팅' 이란?
//         - '함수 호이스팅'은 함수 선언문이 '실행 전에 메모리에 먼저 등록되어 있는 현상'을 말합니다.
//         - 이로 인해 함수 선언문은 '코드에서 먼저 호출하고 나중에 정의해도 실행됩니다.'
        
//         ```jsx
//         sayHello(); // ✅ 실행됨
        
//         function sayHello() {
//           console.log("안녕하세요!");
//         }
//         ```
        
//         '👉 이런 현상으로 인해 함수 선언문은 코드의 진행 순서를 직관적으로 파악하기 어렵습니다.'
        
//         - 반면, 함수 표현식은 변수에 함수를 할당하는 방식이기 때문에 변수 선언만 호이스팅되고 값 할당은 실행 시점에 이루어집니다.
//         - 즉, 변수는 메모리에 있지만 함수는 아직 정의되지 않았으므로, '정의 이전에 호출하면 오류가 발생합니다.'
        
//         ```jsx
//         sayHello(); // ❌ 에러: sayHello is not a function
        
//         const sayHello = function () {
//           console.log("안녕하세요!");
//         };
//         ```
        
//         '👉 이처럼 함수 표현식은 정의 이후에만 호출할 수 있어서 코드 흐름이 더 예측 가능하고 직관적입니다.'


// 함수 표현식
const add10 = function (x, y) {
  return x + y;
};

// 화살표 함수
const add11 = (x, y) => x + y;
// ==========================================================

// ## ⚠️ 함수 표현식으로 함수를 정의할 시 주의 사항

// 1. 코드에서 함수 표현식은 변수처럼 취급되기 때문에, '정의 전에 호출하려고 하면 오류가 발생합니다.' 함수 선언문처럼 코드 위쪽으로 끌어올려지지 않는다는 점, 꼭 기억해 주세요.
// 2. '`const`로 선언하는 것이 가장 안전합니다'
    
//     함수 표현식은 보통 `const` 키워드를 사용해 선언하는 것이 좋습니다. 함수를 변수에 저장한 뒤, 대부분은 재할당할 필요가 없기 때문입니다. `const`로 선언하면 '실수로 함수를 덮어쓰는 것을 방지할 수 있어 코드 안정성'이 높아집니다.
    
// 3. '함수명을 생략해도 되지만, 상황에 따라 붙여도 좋아요'
    
//     함수 표현식에서는 함수명을 생략하는 경우가 많고, 실제로도 그렇게 작성하는 것이 일반적입니다. 하지만 함수명에 의미 있는 이름을 붙여주면, '디버깅하거나 로그를 추적할 때 훨씬 더 수월하게 원인을 찾을 수 있습니다.'


// ㅇ 함수 표현식, 함수 선언문 차이 표 정리
//  차이         /   [함수 선언문]                   /   [함수 표현식]
//  문법         /   function 키워드로 직접 정의     /   function 키워드로 정의한 함수를 변수에 저장
//  호출 방식    /   함수명을 통해 호출              /   함수를 저장한 변수명을 통해 호출
//  호이스팅     /   정의 전 호출 가능               /   정의 전 호출 시 오류 발생

// 결론적으로 함수 표현식을 익히는 것은 단순한 문법 이상의 의미를 갖습니다.
// 함수형 프로그래밍, React 컴포넌트, 콜백, 클로저, 그리고 화살표 함수까지 이어지는 JavaScript 여정의 첫걸음이기 때문입니다.

// ===========================실습===================================
/**
 *  함수 표현식을 사용하여 함수 선언문으로 선언된 코드를 함수 표현식 함수로 변환해보세요.
 *  코드를 함수로 변환하고 다음 실행코드로 실행했을 때 동일한 내용이 나와야합니다.
 *
 */

// 변환 전
// add 함수
function legacy_add(num1, num2) {
  return num1 + num2;
}
// minus 함수
function legacy_minus(num1, num2) {
  return num1 - num2;
}
// multiple 함수
function legacy_multiple(num1, num2) {
  return num1 * num2;
}
// division 함수
function legacy_division(num1, num2) {
  return num1 / num2;
}

console.log(
  `변환 전: 덧셈 ${legacy_add(10, 5)} 뺄셈 ${legacy_minus(
    10,
    5
  )} 곱셈 ${legacy_multiple(10, 5)} 나눗셈 ${legacy_division(10, 5)}`
);

// 위 코드의 legacy_add, legacy_minus, legacy_multiple, legacy_division을
// 각각 add, minus, multiple, division으로 바꿔보세요.

// add 함수
const addTest1 = function (num1, num2) {
    return num1 + num2;
}
// minus 함수
const minus = function (num1, num2) {
    return num1 - num2;
}
// multiple 함수
const multiple = (num1, num2) => num1 * num2;

// division 함수
const division = function (num1, num2) {
    return num1 / num2;
}

console.log(
  `변환 후: 덧셈 ${addTest1(10, 5)} 뺄셈 ${minus(10, 5)} 곱셈 ${multiple(10,5)} 나눗셈 ${division(10, 5)}`
);

// =======================================================================================

// 3. 목표 : 함수를 호출하는 방법을 이해하고, 전달인자가 매개변수에 할당되는 방식을 명확히 설명할 수 있다.

// '함수는 "정의"만 해두면 끝이 아닙니다. "호출"해야만 동작합니다!'

// 지금까지는 함수를 정의하는 방법을 배웠다면, 즉 '호출하는 방법'을 배울 차례입니다.

// 함수 호출 시 '전달인자(argument)'는 함수의 '매개변수(parameter)'에 순서대로 할당되는 값입니다. 예를 들어 `greet("지민")`처럼 호출하면, "지민"이라는 값이 매개변수에 전달되어 함수 내부에서 활용되는 방식입니다.

// '전달인자와 매개변수의 관계를 명확히 이해하는 것'은 함수 활용의 기본이자 핵심입니다. 이제 본격적으로 함수를 호출해보며, 반복되는 로직을 편리하게 다뤄봅시다!


// ㅇ 함수 호출
// - 함수를 실행하려면 '함수명과 소괄호 `()`를 함께 작성'해야 합니다. 이 소괄호는 '함수 호출 연산자'라고 부르며, 함수 내부 코드를 실행시켜주는 역할을 합니다.
// - 함수 호출 시 괄호 안에는 '0개 이상의 전달인자(argument)'를 넣을 수 있으며, 여러 개일 경우 '쉼표( , )로 구분'합니다. 전달인자는 매개변수에 순서대로 할당됩니다.

// // 함수 정의
// function 함수이름 (매개변수) {
// 	return 반환값;
// }

// // 함수 호출
// 함수이름(전달인자);

// =========================================
// ## ♻️ 인자? 인수? 매개변수? 전달인자?

// '매개변수'와 '전달인자'는 다양한 레퍼런스나 강의에서 다음과 같은 표현으로 '혼용'되기도 합니다:

// - '매개변수' → 인자, 파라미터, parameter
// - '전달인자' → 인수, 아규먼트, argument

// 특히 영어 자료에서는 '*parameter'*와 '*argument'*를 그대로 사용하는 경우가 많고, 한국어로 작성된 자료에서는 '인자', '인수'라는 단어가 뒤섞여 사용되기도 합니다. 하지만 이 콘텐츠에서는 '매개변수'와 '전달인자'라는 용어가 함수의 정의와 호출에서 각각 어떤 역할을 하는지 가장 명확하게 설명해주는 표현이라고 생각하기 때문에, 두 용어를 사용합니다.

// ### 📨 매개변수 (파라미터)
// - 함수를 선언할 때 소괄호 안에 넣는 변수입니다.
// - 함수 본문 내부에서 변수와 동일하게 사용할 수 있으며 외부에서는 접근 할 수 없습니다.

// ### 📥 전달인자 (아규먼트)
// - 함수를 호출할 때 소괄호에 넣어 전달하는 값입니다.
// - 함수 호출 시 전달인자는 순서에 따라 매개변수에 할당됩니다.
// - 전달인자의 개수와 타입에는 제한이 없습니다.
// =========================================

// ## 🔄 함수가 호출되면 어떤 일이 일어날까?
// 함수를 호출하면 '현재 실행 중이던 흐름을 잠시 멈추고', JavaScript는 '호출된 함수 내부로 이동하여' 그 안에 작성된 코드를 실행합니다. 이 과정을 흔히 '실행 흐름이 함수로 옮겨간다'고 표현합니다.

function sayHello(name) {
  console.log("안녕하세요, " + name + "님!");
}

console.log("1. 호출 전");
sayHello("지민");  // ← 이 순간, 흐름이 함수로 이동함
console.log("3. 호출 후");


// ## ❓ 전달인자와 매개변수의 수가 일치하지 않을 때
// JavaScript에서는 함수 호출 시 전달인자의 수와 매개변수의 수가 일치하지 않아도 오류가 발생하지 않습니다. 이는 JavaScript 함수가 매우 유연하게 작동한다는 특징 중 하나입니다.

// - 전달인자가 더 많으면: 초과된 전달인자는 무시됩니다.
// - 전달인자가 더 적으면: 매칭되지 않은 매개변수에는 `undefined`가 자동으로 할당됩니다.

console.log('=================');
// ✅ 예시 1. 전달인자가 매개변수보다 많은 경우
function printName(name) {
  console.log("이름:", name);
}

printName("지민", "민수", "수빈");
// 출력: 이름: 지민
// 나머지 전달인자(민수, 수빈)는 무시됩니다.

// ✅ 예시 2. 전달인자가 매개변수보다 적은 경우
function printFullName(firstName, lastName) {
  console.log("성:", lastName);
}

printFullName("지민");
// 출력: 성: undefined
// lastName이 전달되지 않았기 때문에 undefined가 할당됩니다.

// ✅ 예시 3. 매개변수에 기본값을 설정한 경우
// - 매개변수가 undefined일 때 사용할 기본값을 설정할 수 있습니다.
// 이 방식은 전달인자가 생략될 수 있는 상황에 매우 유용합니다.

function greet(name = "게스트") {
  console.log("안녕하세요, " + name + "님!");
}

greet();         // 출력: 안녕하세요, 게스트님!
greet("지민");   // 출력: 안녕하세요, 지민님!


// ### 💡 요약
// - JavaScript 함수는 전달인자의 개수에 강제성이 없습니다.
// - '매개변수가 부족한 경우에는 `undefined`가 자동으로 채워지고', '많은 경우에는 초과 인자가 무시됩니다'.
// - 필요한 경우 기본값(default value)을 설정해 함수의 동작을 더 안정적으로 만들 수 있습니다.


// ⚠️ 함수 호출 시 주의 사항
// 1. 변수에 함수명을 할당하는 것과, 함수의 호출 결과를 할당하는 것은 전혀 다른 방식으로 동작합니다.
// - 변수에 함수명을 할당하면 정의된 함수 객체가 전달됩니다.
// - 함수 이름()처럼 괄호를 붙이면 함수를 즉시 실행하고 함수의 반환값을 할당합니다.
function testAdd(num1, num2) {
  return num1 + num2;
}

const answer1 = testAdd;      // 함수 자체를 할당 (함수 전달)
const result = add(2, 5); // 함수 실행 결과를 할당 (함수 호출)

console.log(answer1(3, 4)); // 7 (answer도 이제 add 함수)
console.log(result);       // 7

// 2. 괄호 ()를 붙이지 않으면 함수는 호출되지 않습니다
// - 괄호가 없으면 함수 객체만 참조하게 되고, 실제로는 아무 동작도 하지 않습니다.
// - 예: sayHello; → 함수 참조만, sayHello(); → 함수 호출
// - 이 실수는 특히 이벤트 핸들러나 콜백 함수 설정 시 자주 발생합니다.
function sayHello() {
  console.log("안녕하세요!");
}

sayHello;    // 아무 일도 일어나지 않음
sayHello();  // 콘솔에 "안녕하세요!" 출력됨

// 3. 반환값이 없는 함수는 undefined를 반환합니다
// - return문이 없는 함수는 자동으로 undefined를 반환합니다.
// - 따라서 반환값이 필요한 함수에서는 return을 명시하는 습관이 중요합니다.
function logMessage() {
  console.log("출력만 하고 반환은 없습니다.");
}

const result2 = logMessage(); // "출력만 하고 반환은 없습니다." 출력
console.log(result2);         // undefined


// ㅇ 함수는 "정의 → 호출 → 실행 → 반환"의 흐름을 갖습니다
// 이 흐름을 이해하면 함수의 진짜 가치를 체감할 수 있습니다. 함수를 한 번 정의해 두면, 같은 작업을 반복할 때마다 새로 코드를 작성할 필요 없이 그저 함수만 호출하면 됩니다.
// 코드가 간결해지고, 유지보수와 재사용이 쉬워지며, 논리 단위로 로직을 나눌 수 있어 가독성과 설계력도 향상됩니다.

// ===================================실습===================================
/**
 *  함수 표현식으로 선언된 내용을 함수 호출로 실행시켜보세요.
 *  add 함수를 사용하는 방법을 보고, minus, multiply, divide 함수도 호출해보세요.
 *
 *  실행 방법: 아래 Terminal에 아래있는 코드를 붙여넣어 주세요.
 *  node main.js
 */

// add 함수를 호출하는 예시는 다음과 같습니다.
console.log('==========실습===========')
// add 함수
let add100 = function (num1, num2) {
  console.log(num1 + num2);
};

add100(10, 7); // 17

// add 함수의 호출 방식을 minus2, multiply2, divide2 함수에도 적용해보세요.

// minus2 함수
let minus2 = function (num1, num2) {
  console.log(num1 - num2);
};

// 여기에 코드를 적어주세요(minus)
minus2(20, 5);

// multiply 함수
let multiple2 = function (num1, num2) {
  console.log(num1 * num2);
};

// 여기에 코드를 적어주세요(multiply)
multiple2(5, 10);

// divide 함수
let divide2 = function (num1, num2) {
  console.log(num1 / num2);
};

// (나눗셈의 경우, 0으로 나누면 에러가 날 수 있습니다.)
// 여기에 코드를 적어주세요(divide)
divide2(10, 5);
// ==============================================================================

// 4. 목표 : return문을 사용하여 함수의 결과값을 반환하는 방법을 이해하고, 반환된 값을 함수 외부에서 활용할 수 있다.

// 함수를 실행만 하고 끝내면 아쉽겠죠? 결과값을 밖으로 '반환'할 수 있어야 진짜 함수처럼 쓸 수 있습니다!
// 이번에는 함수 내부에서 계산된 값을 return 문을 통해 함수 외부로 전달하는 방법을 배워봅니다. 반환된 값은 변수에 저장하거나, 다른 함수에 전달하거나, 직접 출력하는 등 다양하게 활용할 수 있습니다.
// 함수는 단순히 어떤 작업을 수행하는 도구를 넘어, 결과를 되돌려주는 도구이기도 합니다. 이 과정을 이해하면 코드의 재사용성, 확장성, 그리고 논리적인 설계 능력이 훨씬 향상됩니다!

// 📤 함수의 반환
// 반환(返還)은 사전적으로 ‘'돌려주는 것’'을 의미합니다. JavaScript 함수에서의 반환(return)은 '함수 내부에서 계산된 값을 함수 외부로 돌려주는 것'을 말하며, 반환된 값은 '변수에 할당하거나 다른 연산에 활용'할 수 있습니다.

// 이 과정에서 함수 호출에 의해 호출된 함수로 이동한 '실행 흐름'은 `return`문을 만나면 호출 지점으로 되돌아갑니다.

console.log('==================');
// 함수 선언문
function add3(num1, num2) {
	// return 키워드를 이용한 반환값 반환
	return num1 + num2;
}

// 함수 호출 및 반환값을 answer 변수에 저장
let answer3 = add3(2, 5); 

// answer 변수에 저장된 반환값을 콘솔에 출력
console.log(answer3); // 7

// * 실행 흐름(flow of execution) - 그냥 단어 적어놓음

// ㅇ 활용
// - 함수는 반환값을 변수나 배열과 같은 값에 할당하여 사용할 수 있습니다.
function recommend() {
  return "추천 메뉴는 김치볶음밥입니다.";
}

const lunch = recommend(); // lunch에 "추천 메뉴는 김치볶음밥입니다." 할당
console.log(lunch); // 추천 메뉴는 김치볶음밥입니다.
console.log('========================');
// ➕ 반환값을 활용한 연산 예시
// 함수가 반환하는 값은 변수에 저장할 수 있을 뿐 아니라, 다른 연산에 활용하거나, 또 다른 함수에 전달할 수도 있습니다. 이러한 구조를 활용하면 복잡한 로직도 작은 단위로 나눠 구현할 수 있어 유지보수가 쉬워집니다.
// ✅ 예시 1: 음식 가격 계산 후 할인 적용
function getTotalPrice(kimbapCount, ramenCount) {
  return (kimbapCount * 3500) + (ramenCount * 5000);
}

function applyDiscount(price) {
  return price * 0.9; // 10% 할인
}

const total = getTotalPrice(2, 1);        // 2줄 김밥 + 1개 라면
const discounted = applyDiscount(total);  // 반환값을 다시 연산

console.log("총 결제 금액:", discounted); // 총 결제 금액: 10800

// ✅ 예시 2: 평균 점수 반환 → 학점으로 변환
function calculateAverage(kor, eng, math) {
  return (kor + eng + math) / 3;
}

function getGrade(avg) {
  if (avg >= 90) return "A";
  if (avg >= 80) return "B";
  return "C";
}

const average = calculateAverage(85, 90, 92);
const grade = getGrade(average);

console.log("평균 점수:", average);  // 평균 점수: 89
console.log("학점:", grade);        // 학점: B

// ### ❓ `return`과 `console.log()`는 어떻게 다를까요?
// - JavaScript를 처음 배우는 분들이 가장 많이 헷갈리는 개념 중 하나가 바로 `return`과 `console.log()`입니다. 둘 다 코드에서 '무언가를 보여주는 것처럼 보이지만', 실제로는 '역할이 완전히 다릅니다.' 
// - '`return`은 함수의 실행 결과를 함수 외부로 '돌려주는 것''이고, '`console.log()`는 그 결과나 값을 단순히 '화면에 출력'하는 도구'입니다.
function getNumber() {
  console.log(1);     // 콘솔에 1을 출력 (눈에 보이는 결과)
  return 1;           // 함수 외부로 값을 반환 (코드 상의 데이터 전달)
}

const getResult = getNumber();  // getNumber()의 반환값이 result에 저장됨
console.log(getResult);         // 콘솔에 1을 출력

// 즉, console.log()는 디버깅용, return은 로직 처리를 위한 필수 도구입니다. 

// ## ⚠️ 함수 호출 시 주의 사항
// 1. 함수는 `return` 키워드 없이도 함수 본문의 실행이 끝나면 자동으로 종료됩니다. 이때, 반환값은 `undefined`입니다.
function hello1() {
    let greet = "안녕하세요, JavaScript";
}
console.log(hello1()); // undefined

// 2. return 키워드를 여러번 사용할 경우, 가장 상위에 있는 return키워드만 실행되고, 나머지 return 키워드는 무시됩니다.
function hello2() {
    let hi = "안녕하세요, JavaScript";
    let greet = "hello, JavaScript";
    return hi;
    return greet;
}
console.log(hello2()); // 안녕하세요, JavaScript


// return은 단순히 함수의 작업을 끝내는 도구가 아닙니다. 계산된 값을 함수 바깥으로 전달하고, 그 값을 다른 연산에 활용할 수 있게 하는 출발점입니다.

// 반환값은 다른 함수의 인자로도, 연산의 재료로도, 출력의 결과로도 얼마든지 활용될 수 있습니다. 이런 방식으로 함수를 조합하면 '복잡한 로직도 간단한 블록처럼 구성할 수 있는 힘'을 갖게 됩니다.

// 함수 하나를 만들고 끝내는 것이 아니라, 그 결과를 다음 단계로 계속 이어가는 방식. 바로 이 흐름이 '현업 개발에서도 가장 많이 쓰이는 함수 활용법'입니다. 지금부터는 단순히 함수를 만드는 데 그치지 말고, '"이 함수의 결과값을 어떻게 활용할 수 있을까?"'를 고민해 보세요.

// '그 질문 하나가 훨씬 더 유연하고 확장성 있는 코드를 만드는 첫걸음이 될 거예요.'

// =========================실습==============================================
/**
 *  return 문을 활용하여 함수의 반환을 구성해보세요.
 *
 *  실행 방법: 아래 Terminal에 아래있는 코드를 붙여넣어 주세요.
 *  node main.js
 */

// 1. add 함수의 반환값을 작성해주세요.
console.log('--------실습----------');

function addNum(num1, num2) {
    return num1 + num2;
}

console.log(addNum(17, 23)); // 40

// 2. add 함수를 2번 호출한 후, 두 반환값을 더하는 코드를 구현해주세요.

// 여기에 코드를 작성해주세요.
let addAdd = add(10, 10) + add(5, 5);
console.log(addAdd);
// 실행 방법: 아래 Terminal에 아래있는 코드를 붙여넣어 주세요.
// node main.js
// ==================================================================

// 5. 목표 : 함수를 사용하는 이유(재사용성, 코드의 가독성 향상, 유지보수 용이성)를 나열할 수 있다.

// '함수를 사용하는 가장 큰 이유는 재사용성입니다.'

// 즉, 한 번 정의해 두면 필요할 때마다 호출해서 사용할 수 있어 '같은 작업을 반복해서 작성'하지 않아도 됩니다. 뿐만 아니라 코드를 '논리적인 블록으로 분리'할 수 있어 전체 코드의 '가독성'이 향상되고, 수정이 필요한 경우 해당 함수만 고치면 되기 때문에 '유지보수도 훨씬 쉬워집니다.'

// 📌 정리하자면, 함수는

// - '반복되는 작업을 효율적으로 처리할 수 있고'
// - '코드를 더 읽기 쉽게 만들며'
// - '변경과 확장이 쉬운 구조로 개선'해 줍니다.

// 함수는 단순한 도구가 아니라, '좋은 코드를 만드는 핵심적인 개념'입니다. 지금 이 개념에 익숙해지는 것이 앞으로의 학습과 실무에 큰 도움이 될 거예요!


// 💬 함수를 사용하는 이유
// 함수는 '일련의 과정(로직)을 하나의 코드 블록으로 정의'할 수 있는 'JavaScript의 핵심 개념'입니다.
// 함수를 호출하면 전달인자를 통해 외부에서 함수 내부의 매개변수에 값을 전달하게 되며, 함수는 이 값을 기반으로 일련의 과정(로직)을 처리한 뒤 `return` 키워드를 통해 결과값을 반환합니다.
// 반환된 값은 변수나 배열 등에 저장하거나 다른 로직에 활용할 수 있어, '코드의 흐름을 유연하게 구성'할 수 있습니다.
// 함수는 '반복 작업을 줄이고 로직을 효율적으로 구성하기 위한 핵심 도구'로, '재사용성, 가독성, 유지보수성' 측면에서도 매우 유리해 실무에서도 널리 활용됩니다.

// 1️⃣ 1. 재사용성
// '함수는 반복되는 작업을 하나의 코드로 정의함으로써, 불필요한 중복을 줄이고 효율적으로 재사용할 수 있도록 돕는 도구입니다.'

// 마트에서 물품의 할인가를 계산하는 상황을 예시로 들어보겠습니다.

// ### '❌ 함수를 사용하지 않은 경우'
// 매번 같은 계산식을 반복 작성해야 하므로, 품목이 많아질수록 코드가 길어지고 관리도 어려워집니다.

// 10% 할인, 원가: 2,100원, 할인가: 1,890원
const drink = 2100 - 2100 * 0.1; 
// 20% 할인, 원가: 13,000원, 할인가: 10,400원
const banana = 13000 - 13000 * 0.2; 
// 15% 할인, 원가: 7,200원, 할인가: 6,120원
const cake = 7200 - 7200 * 0.15; 
// 30% 할인, 원가: 1,300,000원, 할인가: 910,000원
const television = 1300000 - 1300000 * 0.3; 
// 5% 할인, 원가: 271,200원, 할인가: 257,635원
const monitor = 271200 - 271300 * 0.05; 

// ### '✅ 함수를 활용한 경우'

// '할인가를 계산하는 로직을 함수로 정의해두면', 어떤 상품이든 가격과 할인율만 전달해 쉽게 계산할 수 있습니다.
// 할인가를 계산하는 함수 discountPriceCalculator() 정의
function discountPriceCalculator(originPrice, discount) {
	// 할인가를 계산하여 반환
  return originPrice - originPrice * discount;
}

// 함수 discountPriceCalculator()에 원가와 할인률을 전달하여 할인가 계산
// 10% 할인, 원가: 2,100원, 할인가: 1,890원
const drink1 = discountPriceCalculator(2100, 0.1);
// 20% 할인, 원가: 13,000원, 할인가: 10,400원
const banana1 = discountPriceCalculator(13000, 0.2);
// 15% 할인, 원가: 7,200원, 할인가: 6,120원
const cake1 = discountPriceCalculator(7200, 0.15);
// 30% 할인, 원가: 1,300,000원, 할인가: 910,000원
const television1 = discountPriceCalculator(1300000, 0.3);
// 5% 할인, 원가: 271,200원, 할인가: 257,640원
const monitor1 = discountPriceCalculator(271200, 0.05);


// ### '📌 복잡한 로직일수록 함수의 재사용성은 더 큰 힘을 발휘합니다.'

// 이 예시는 '입력값을 검사하는 함수(validateInputField)'와 '상태를 저장하고 가져오는 함수(makeState)'를 활용하여 로그인 입력값의 유효성을 검사하는 흐름을 보여줍니다.

// 특히 `makeState` 함수는 'React의 상태 관리(useState)' 방식과 비슷한 로직을 갖고 있어, 나중에 React를 배울 때 큰 도움이 됩니다. 아직은 다소 낯설 수 있지만, '복잡한 기능도 작은 단위의 함수로 분리해서 만들 수 있다는 점', 그리고 '이렇게 만든 함수를 재사용할 수 있다는 점'을 느껴보는 데 목적이 있습니다.

// 처음에는 어렵게 느껴질 수 있지만, 함수의 재사용성이 왜 중요한지를 실감할 수 있는 좋은 예시입니다. '처음엔 코드 흐름만 따라가 보면서 익숙해지는 것부터 시작해도 충분합니다.'

// 📦 상태를 저장하고 불러오는 함수 (간단한 상태 관리)
function makeState(initialValue = null) {
  let state = initialValue;

  // 상태를 변경하는 함수
  function setState(newValue) {
    state = newValue;
  }

  // 현재 상태를 반환하는 함수
  function getState() {
    return state;
  }

  // 상태 접근자(get)와 설정자(set)를 배열로 반환
  return [getState, setState];
}

// 🔧 상태 생성
const [getId, setId] = makeState("");           // 아이디 상태 초기화
const [getPassword, setPassword] = makeState("123"); // 패스워드 상태 초기화

// 🧪 유효성 검사 함수
function validateInputField(inputValue, type) {
  switch (type) {
    // ID 유효성 검사
    case 'id':
      if (inputValue === "") {
        return {
          valid: false,
          errorMessage: "필수 입력값입니다."
        };
      }
      return {
        valid: true,
        errorMessage: ""
      };

    // 비밀번호 유효성 검사
    case 'pw':
      if (inputValue === "") {
        return {
          valid: false,
          errorMessage: "필수 입력값입니다."
        };
      }

      if (inputValue.length < 8) {
        return {
          valid: false,
          errorMessage: "비밀번호는 8자리 이상이어야 합니다."
        };
      }

      return {
        valid: true,
        errorMessage: ""
      };
  }
}

// ✅ 유효성 검사 결과 확인
console.log(validateInputField(getId(), "id")); // { valid: false, errorMessage: '필수 입력값입니다.' }
console.log(validateInputField(getPassword(), "pw")); // { valid: false, errorMessage: '비밀번호는 8자리 이상이어야 합니다.' }

// 2️⃣ 2. 코드 가독성
// 함수는 내부 동작을 전부 알지 못하더라도, 함수 이름만으로 어떤 기능을 수행하는지 유추할 수 있도록 돕는 도구입니다.
// 이처럼 함수를 잘 활용하면 코드가 더 읽기 쉽고, 협업이나 유지보수 시에도 큰 도움이 됩니다. 특히 코드의 목적을 드러내는 이름을 짓는 습관은 실무에서 매우 중요하게 여겨집니다.

// ✅ 함수가 가독성을 높이는 이유, 더 깊이 보기
// 1. '코드의 ‘의도’를 한눈에 파악할 수 있습니다'
    
//     변수에 직접 수식을 작성하면, 그 계산이 왜 필요한지 일일이 해석해야 합니다. 하지만 함수를 사용하면 `할인가 계산`, `총합 계산`, `평균 구하기` 등 '의도와 역할을 함수명에 담을 수 있기 때문에 읽는 사람이 빠르게 맥락을 파악할 수 있습니다.'
//     마트 할인가 계산 코드를 다시 보면, 주석이 없을 경우 각 계산식이 어떤 품목을 다루고 어떤 할인율이 적용되었는지 파악하기 어렵습니다.

// 예시코드
// const drink = 2100 - 2100 * 0.1; 
// const banana = 13000 - 13000 * 0.2;
// const cake = 7200 - 7200 * 0.15;
// const television = 1300000 - 1300000 * 0.3;
// const monitor = 271200 - 271300 * 0.05;

// 반면 함수를 사용하면, 계산식을 별도로 분석하지 않아도 함수명만 보고 기능을 파악할 수 있습니다. 즉, 코드의 의도를 더 쉽게 읽고 이해할 수 있게 되는 것입니다.
// 예시코드
// function discountPriceCalculator(originPrice, discount) {
//   return originPrice - originPrice * discount;
// }

// const drink = discountPriceCalculator(2100, 0.1);
// const banana = discountPriceCalculator(13000, 0.2);
// const cake = discountPriceCalculator(7200, 0.15);
// const television = discountPriceCalculator(1300000, 0.3);
// const monitor = discountPriceCalculator(270000, 0.05);


// 2. 코드의 구조를 상위 개념으로 추상화할 수 있습니다

// 함수는 세부 로직을 감추고, 상위 개념만 노출시킵니다. 즉, '"무엇을 하는가"에 집중하게 하고 "어떻게 하는가"는 잠시 감춰줍니다.'
// 이는 글에서 문단 제목만 읽고도 전체 내용을 예측할 수 있는 것과 유사합니다.

// 3. '길고 복잡한 코드를 분리해서 이해하기 쉽게 나눌 수 있습니다'

//  기능별로 함수를 나누면 하나의 함수 안에 너무 많은 일을 담지 않게 되고, '읽기 좋고, 수정하기 쉬운 코드'가 됩니다.
// 예시코드) 장바구니의 총 결제 금액을 계산하는 함수
function calculateTotalPrice() {
  // 1. 장바구니에 담긴 상품 목록을 가져옴
  const items = getCartItems();

  // 2. 상품들의 총합(소계)을 계산
  const subtotal = calculateSubtotal(items);

  // 3. 소계를 기준으로 세금 계산
  const tax = calculateTax(subtotal);

  // 4. 소계와 세금을 더해 총 결제 금액 반환
  return subtotal + tax;
}
// 위와 같은 방식은 로직을 단계별로 분리하고, 각각의 단계가 어떤 역할을 하는지 명확하게 보여줍니다.

// 4. '팀 개발 시 다른 사람과의 협업을 원활하게 합니다'
    
// 가독성이 좋으면 코드 리뷰도 수월하고, 다른 사람이 코드를 분석하는 데 드는 시간이 줄어듭니다.
// 특히 '함수명만 보고도 ‘무슨 일을 하는 코드인지’ 이해할 수 있으면 훨씬 빠르게 업무에 적응할 수 있습니다.'


// ## 3️⃣ 3. 유지보수

// 함수를 활용하면 코드의 '오타 가능성을 줄이고, 수정과 확장이 쉬워지는' 장점이 있습니다. 특히 '여러 곳에서 반복되는 로직이 있을 때', 함수를 사용하면 단 한 곳만 수정해도 전체 코드에 적용되는 효과를 얻을 수 있어 유지보수가 매우 효율적입니다.

//  문제 상황: 오타와 반복 수정
// 예시코드 - 할인가 계산
// const drink = 2100 - 2100 * 0.1; // 10% 할인
// const banana = 13000 - 13000 * 0.2; // 20% 할인
// const cake = 7200 - 7200 * 0.15; // 15% 할인
// const television = 1300000 - 1300000 * 0.3; // 30% 할인
// const monitor = 271200 - 271300 * 0.05; // ❗ 오타: 가격이 다르게 입력됨

// - `monitor` 항목에서 '계산 대상이 잘못 입력되는 오타가 발생'했습니다.
// - 이처럼 같은 패턴의 계산을 여러 줄 작성하다 보면 '사소한 실수가 숨어 있어도 놓치기 쉽고', 나중에 전체 코드를 일일이 검토해야 수정할 수 있습니다.

// 반면, 같은 계산식을 함수로 만들면, 다음과 같은 이점이 생깁니다.
// 1. '오타를 줄이고 로직을 한눈에 검토 가능'
// 2. '수정 시 함수 한 곳만 바꾸면 전체 반영'
// 3. '할인 이벤트 변경 등 요구사항 대응이 쉬움'
// 할인가를 계산하는 함수
// function discountPriceCalculator(originPrice, discount) {
//   return originPrice - originPrice * discount;
// }

// const drink = discountPriceCalculator(2100, 0.1);
// const banana = discountPriceCalculator(13000, 0.2);
// const cake = discountPriceCalculator(7200, 0.15);
// const television = discountPriceCalculator(1300000, 0.3);
// const monitor = discountPriceCalculator(271200, 0.05); // 오타 없이 일관된 계산

// 또, 마트에서 "기존 할인 가격에 추가 10% 할인"을 적용한다고 가정해 봅시다. 함수를 사용하지 않았다면 모든 계산식을 다시 수정해야 합니다. 그러나 함수로 정의되어 있다면, 단 한 줄만 수정하면 됩니다:
// 기존 할인 + 추가 10% 할인까지 반영된 함수
// function discountPriceCalculator(originPrice, discount) {
//   const discounted = originPrice - originPrice * discount;
//   return discounted * 0.9;
// }


// '함수는 단순히 코드 줄 수를 줄이기 위한 도구가 아닙니다. 복잡한 로직을 작게 나누고, 중복을 제거하며, 유지보수를 쉽게 하고, 코드를 읽기 쉽게 만드는 핵심 도구입니다.'

// - 같은 작업을 반복할 때 '재사용성'이 극대화되고
// - 복잡한 코드를 '함수 이름만 보고도 파악할 수 있게' 해주며
// - 한 곳만 수정하면 전체에 반영되는 '유지보수성'까지

// JavaScript 실력은 함수를 얼마나 자유자재로 설계하고 다룰 수 있는지에서 차이가 납니다.

// '지금부터 함수에 익숙해지는 것, 그것이 진짜 개발자에 가까워지는 첫 걸음입니다!'


// ===============================실습=====================================
// 우영우가 팰린드롬인지 확인하는 코드
const str = '우영우';
let isPalindrome = true;

for (let i = 0; i < str.length / 2; i++) {
  if (str[i] !== str[str.length - 1 - i]) {
    isPalindrome = false;
    break;
  }
}

console.log(`"${str}"은 팰린드롬인가? ${isPalindrome}`);

// 함수로 작성하여 다음 문자열들이 팰린드롬인지 확인해보세요.

/**
 * 팰린드롬인 문자열
 * - 아시아
 * - 오레오
 * - 일요일
 * - 부산임산부
 * - 가련하시다사장집아들딸들아집장사다시하련가
 * 팰린드롬이 아닌 문자열
 * - 오즈코딩스쿨
 * - 자바스크립트
 * - 프론트엔드
 * - 촉촉한나라의초코칩
 */

// 여기에 코드를 작성해주세요.
function palindromeChecker(str) {
    isPalindrome = true;
    for(let i = 0; i < str.length / 2; i++) {
        if(str[i] !== str[str.length - 1 - i]) {
            isPalindrome = false;
            break;
        }
    }
    return isPalindrome;
}
// 정답코드
// function palindromeChecker(str) {
//   for (let i = 0; i < str.length / 2; i++) {
//     if (str[i] !== str[str.length - 1 - i]) {
//       return false;
//     }
//   }
//   return true;
// }

const inputStr = '부산임산부';
console.log(`"${inputStr}"은 팰린드롬인가? ${palindromeChecker(inputStr)}`);

// ==========================================================================


// 6. 목표 : 함수 내부에서 선언된 변수를 함수 외부에서 사용할 수 없다는 것을 기억할 수 있다.

// ㅇ '함수 내부에 선언한 변수는 외부에서 사용할 수 없습니다.'
// - JavaScript에서 함수는 '자신만의 범위(scope)'를 가집니다. 이 범위는 변수가 유효하게 작동할 수 있는 범위를 의미합니다.
// - '이 범위는 변수가 선언된 위치에 따라 달라집니다.'

// 📚 함수 내부 변수의 유효 범위

// ## 📕 함수 내부에서 선언한 변수는 함수 내부에서만 유효합니다.

// 함수 내부에서 선언한 변수는 그 함수 안에서만 사용할 수 있습니다. 아래 예제를 보시겠습니다.

function sayHello() {
  let message = '안녕하세요';
  console.log(message); // ✅ '안녕하세요' 출력
}

sayHello();
// - 변수 `message`는 함수 `sayHello` 내부에 선언되어 있습니다.
// - 따라서 해당 함수 안에서 `console.log(message)`를 실행하면 정상적으로 출력됩니다.

// 📗 매개변수도 함수 내부에서만 유효합니다
// 함수의 매개변수는 함수 호출 시 외부에서 값을 전달받는 역할을 합니다. 
// 이 매개변수 역시 함수 내부에서만 사용할 수 있습니다.
function greet(name) {
  console.log('반갑습니다, ' + name + '님!');
}

greet('영희'); // ✅ '반갑습니다, 영희님!' 출력
// - 매개변수 `name`은 함수 내부에서만 유효합니다.
// - 외부에서는 사용할 수 없습니다.

// 📘 함수 외부에서는 내부 변수에 접근할 수 없습니다
// 함수 내부에서 선언한 변수는 외부에서 사용할 수 없습니다.
// 아래와 같이 코드를 작성하면 오류가 발생합니다.
// function sayHi() {
//   let hi = '안녕하세요';
// }

// console.log(hi); // Uncaught ReferenceError: hi is not defined
// - 변수 `hi`는 `sayHi()` 함수 내부에만 존재하는 지역 변수입니다.
// - 함수 바깥에서는 이 변수를 전혀 알 수 없기 때문에 에러가 발생합니다.


// ## ⚠️ 사용 시 주의 사항
// - 함수 내부에서 선언한 변수는 함수 외부에서 사용할 수 없습니다.
// - 매개변수 역시 함수 내부에서만 유효합니다.
// - 함수 외부에서 내부 변수를 사용하려고 하면 `ReferenceError`가 발생합니다.
// - 코드를 작성할 때, '변수가 어디서 선언되었고, 어디서 사용 가능한지 항상 의식하는 습관'이 필요합니다.


// '지금은 변수의 유효 범위가 함수로 구분된다는 사실만 명확히 기억해 둡시다.'
// 이 개념은 앞으로 학습할 '스코프, 실행 컨텍스트, 클로저, this' 같은 중요한 개념의 기초가 됩니다.
// '내부에서 선언한 변수는 내부에서만 유효하다.' 이것 하나만 확실히 익히셔도 다음 단계 학습에 큰 도움이 됩니다!
// -------------------------실습--------------------------------------------

/**
 * 아래 코드를 실행하여 함수 내부와 외부에 선언된 변수를 사용할 수 있는 범위를 눈으로 확인해보세요.
 *
 * 코드를 추가하거나 변수를 수정하여 실행해보는 방법도 좋습니다.
 *
 * 코드 실행 방법
 * 아래 Terminal에 아래 코드를 작성해주세요.
 * node main.js
 */

// function dep1() {
//   let num1 = 1;
//   function dep2() {
//     let num2 = 2;
//     function dep3() {
//       let num3 = 3;
//       console.log(num1); // 1
//       console.log(num2); // 2
//       console.log(num3); // 3
//     }
//     console.log(num1); // 1
//     console.log(num2); // 2
//     console.log(num3); // ReferenceError: num3 is not defined
//   }
//   console.log(num1); // 1
//   console.log(num2); // ReferenceError: num2 is not defined
//   console.log(num3); // ReferenceError: num3 is not defined
// }
// console.log(num1); // ReferenceError: num1 is not defined
// console.log(num2); // ReferenceError: num2 is not defined
// console.log(num3); // ReferenceError: num3 is not defined

// ============================================================================

// 7. 목표 : (심화편 - 스코프) 함수 내부에서 선언된 변수를 함수 외부에서 사용할 수 없다는 것을 기억할 수 있다.

// '함수 내부에서 선언된 변수는 외부에서 사용할 수 없습니다.'

// JavaScript에서 함수는 '자신만의 독립적인 범위(스코프)'를 가집니다.

// 따라서 함수 내부에서 선언한 변수는 함수 외부에서 접근할 수 없습니다.

// '이 원리를 이해하면 실행 컨텍스트, 호출 스택, 클로저, this 등 JavaScript의 핵심 동작 원리를 배우는 데 중요한 기반이 됩니다.'


// # 🔭 스코프 (Scope)
// - 변수나 함수가 어디에서 선언되었느냐에 따라 접근할 수 있는 범위를 의미합니다.
// - JavaScript는 이 선언 위치를 기준으로 전역 스코프와 지역 스코프를 구분하며, 스코프를 벗어나면 해당 식별자에 접근할 수 없습니다.

// ## 🗺️ 전역 스코프와 지역 스코프

// '전역 스코프'는 코드 전체에서 접근 가능한 범위를 의미하며, '지역 스코프'는 블록(`{}`)으로 구분되는 제한된 범위를 의미합니다. 변수나 함수가 선언된 위치에 따라 이 둘 중 하나의 스코프를 갖습니다.

// ✅ 예제 1: 전역 스코프
// - 전역에서 선언한 변수는 코드 어디에서든 접근할 수 있습니다. 함수 내부에서도 사용할 수 있습니다.
let greeting = '안녕하세요';

function sayHelloTest() {
  console.log('함수 내부에서:', greeting); // ✅ 안녕하세요
}

console.log('함수 외부에서:', greeting);   // ✅ 안녕하세요
sayHelloTest();
// - 변수 `greeting`은 '전역 스코프(global scope)'에 선언되어 있으므로,
//     - 함수 외부에서도 사용할 수 있고
//     - 함수 내부에서도 사용할 수 있습니다.

// ❌ 예제 2: 지역 스코프
// - 반대로 함수 내부에 선언한 변수는 '해당 함수 안에서만' 사용할 수 있습니다.
// - 함수 외부에서는 접근할 수 없습니다.
// function sayHi2() {
//   let message = '반가워요';
//   console.log('함수 내부에서:', message); // ✅ 반가워요
// }

// sayHi2();
// console.log('함수 외부에서:', message);   // ❌ ReferenceError: message is not defined
// - 변수 `message`는 '함수 내부(지역 스코프)'에 선언되어 있기 때문에
//     - 함수 내부에서는 사용할 수 있지만
//     - 함수 외부에서는 사용할 수 없습니다.

// 전역 스코프는 오직 하나만 존재하며, 지역 스코프는 블록을 생성함으로써 언제든 만들 수 있습니다. 특히 함수는 블록으로 감싸지므로 실행할 본문 자체가 지역 스코프가 됩니다. 또한 지역 스코프는 중첩이 가능하며, 함수 내부에 또 다른 함수를 정의하면 지역 스코프 안에 또 다른 지역 스코프가 생성됩니다.


// 🔝 상위 스코프와 하위 스코프
function outerFunc() {
    let number1 = 1;
    function innerFunc() {
        let number2 = 2;
        console.log(number1, number2);
    }
}
// 위 예제에서 내부 함수 `innerFunc()`는 외부 함수 `outerFunc()`의 '지역 스코프 내부에서 정의'되었기 때문에, `innerFunc()`가 만들어내는 지역 스코프에서는 `outerFunc()`의 지역 스코프에 '접근할 수 있습니다'. 따라서 `outerFunc()`의 스코프는 `innerFunc()` 입장에서 '상위 스코프'입니다.

// 반대로 `outerFunc()`의 지역 스코프에서는 `innerFunc()`의 지역 스코프에 '직접 접근할 수 없습니다'. 즉, `innerFunc()`는 `outerFunc()` 내부에서만 존재하며, 외부에서는 사용할 수 없습니다. 따라서 `innerFunc()`의 스코프는 `outerFunc()` 입장에서 '하위 스코프'가 됩니다.

// 이처럼 '상위 스코프와 하위 스코프는 상대적인 개념'이며, 기준이 되는 함수에 따라 위치가 달라질 수 있습니다.

// - `innerFunc`이 만든 지역 스코프는 `outerFunc`에 의한 지역 스코프의 하위 스코프
// - `outerFunc`이 만든 지역 스코프는 `innerFunc`에 의한 지역 스코프의 상위 스코프


// 📍 전역 변수와 지역 변수
// 전역 변수는 전역 스코프에 선언된 변수이고, 지역 변수는 지역 스코프에 선언된 변수입니다.

// - 지역 변수는 특정 블록(`{}`), 특히 함수 내부에서 선언된 변수이며, 해당 스코프 내부 또는 하위 스코프에서만 사용할 수 있습니다.
// - 반면, 전역 변수는 전역 스코프에 존재하므로 어디에서든 접근이 가능합니다.

// let globalMessage = "전역 변수입니다."; // 전역 변수

// function showMessage() {
//   console.log(globalMessage); // ✅ 전역 변수 접근 가능

//   let localMessage = "지역 변수입니다."; // 지역 변수
//   console.log(localMessage); // ✅ 같은 지역 스코프에서 접근 가능
// }

// showMessage();

// console.log(localMessage); // ❌ ReferenceError: localMessage is not defined


// ### 📌 스코프의 방향성 정리
// - 하위 스코프에서는 상위 스코프에 선언된 변수에 접근할 수 있습니다.
// - 상위 스코프에서는 하위 스코프에 선언된 변수에 접근할 수 없습니다. (`ReferenceError`)

// ## 🚫 전역 변수, 정말 편리할까?

// 전역 변수는 한 번 선언하면 어디서든 접근할 수 있어 편리해 보일 수 있지만,`사용에 매우 신중해야 합니다`
// 다음은 전역 변수의 대표적인 문제점입니다.

// ### 1. 예측 불가능한 동작
// 전역 변수는 어디서든 수정될 수 있기 때문에, 어떤 코드가 변수 값을 바꿨는지 추적하기 어렵습니다. 결과적으로 버그를 찾기 어렵고, 코드의 안정성이 떨어집니다.
let userName = '철수';

function updateName() {
  userName = '영희'; // 전역 변수 직접 수정
}

updateName();
console.log(userName); // ❗ 철수가 영희로 바뀜 (예상치 못한 결과일 수 있음)

// ### 2. 네이밍 충돌의 위험
// 전역 스코프는 하나뿐이기 때문에, '같은 이름의 변수가 여러 파일에서 중복될 수 있습니다.' 
// 이는 특히 규모가 큰 프로젝트에서 치명적인 문제로 이어질 수 있습니다.

// // 파일 A
// let config = { darkMode: true };

// // 파일 B
// let config = { debug: true }; // ❗ 파일 A의 config가 덮어씀

// ### 3. 모듈화/재사용의 어려움
// 전역 변수에 의존하면 '모듈 간의 독립성이 낮아지고', '테스트나 재사용이 어려워집니다.'

// ### ✅ 전역 변수 사용, 이렇게 제한하세요

// - 꼭 필요한 경우에만 사용하고, 그 외에는 '지역 변수' 또는 '함수 파라미터'로 대체하세요.
// - 여러 함수에서 공통으로 사용할 경우에도 '전역 대신 객체의 속성으로 관리'하거나 '모듈화'를 고려하세요.
// - 협업 환경에서는 전역 변수의 사용을 '코딩 규칙으로 제한'하는 것이 좋습니다.


// ## ⚠️ 스코프 사용 시 주의 사항

// 1. '변수나 함수를 어디서 선언했는지 항상 확인해야 합니다'
    
//     - 선언 위치에 따라 전역 스코프인지, 지역 스코프인지가 결정되며, 이는 코드 전체의 동작에 영향을 줍니다.
    
// 2. '지역 스코프에서 선언한 변수는 외부에서 사용할 수 없습니다'
    
//     - 내부에서만 사용하는 값이라면 전역으로 선언하지 않도록 주의해야 합니다.
    
// 3. '스코프 중첩이 깊어질수록 코드의 가독성이 떨어질 수 있습니다'
    
//     - 너무 많은 중첩 함수는 유지보수를 어렵게 만들 수 있으니, 필요한 범위 내에서만 사용하는 것이 좋습니다.
    
// 4. '전역 변수의 남용을 피하세요'
    
//     - 전역 변수는 어디서든 접근할 수 있어 편리하지만, 충돌이나 의도치 않은 변경이 발생할 수 있어 위험합니다.
//     - 가능하다면 필요한 범위에서만 사용할 수 있도록 '지역 변수로 제한'하는 습관을 들이는 것이 좋습니다.


// '스코프는 단순히 변수와 함수의 "사용 가능 여부"를 결정하는 개념처럼 보일 수 있지만, 사실은 JavaScript의 작동 방식 전체를 이해하는 데 기반이 되는 핵심 개념입니다.'

// '변수나 함수를 선언할 때는 항상 그 스코프를 의식해야 하며', 이를 명확히 구분할 수 있어야 코드의 안정성과 예측 가능성이 높아집니다. 스코프 개념을 정확히 이해하고 있다면 이후 학습하게 될 '실행 컨텍스트, 호출 스택, 클로저, this' 등을 훨씬 수월하게 받아들일 수 있습니다.

// 이번 기회에 '스코프 개념을 제대로 익혀두면', 복잡한 로직도 자신 있게 다룰 수 있는 기초 체력을 갖추는 셈입니다. 

// '지금부터 차근차근, 자신감을 갖고 시작해보세요! 💪'