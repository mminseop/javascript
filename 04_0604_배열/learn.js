// 1. 목표 : 배열은 순서 정보(index)를 가지고 있는 자료형이라는 것을 기억한다. 

// 배열은 하나의 변수에 여러 개의 값을 한꺼번에 담을 수 있는 자료형입니다.

// 기존에는 `let a = 1; let b = 2; let c = 3;`처럼 값을 하나씩 저장했다면,
// 배열을 사용하면 `let numbers = [1, 2, 3];`처럼 여러 개의 데이터를 하나의 변수에 저장할 수 있습니다.

// 배열은 각 값을 순서대로 저장하며, 각 요소에는 고유한 번호(인덱스)가 부여됩니다.
// 이 번호를 통해 원하는 값을 꺼내거나 바꿀 수 있어, 많은 데이터를 효율적으로 다룰 때 매우 유용합니다.

// 배열 (array)
// - 여러 개의 값을 하나의 변수에 순서대로 저장할 수 있는 자료형으로, 반복 처리나 데이터 그룹 관리에 매우 유용하게 사용됩니다.
// - 배열에 저장된 각 값은 인덱스(index)라는 고유한 번호로 구분되며, 이 인덱스를 통해 개별 요소에 접근하거나 수정할 수 있습니다.

// 배열의 인덱스
// - 각 값을 순서대로 저장하며, 저장된 값이나 번호가 자동으로 부여
// - 이 번호를 인덱스(index)라고 부르며, 0부터 시작
const students = ['민수', '영희', '철수'];
console.log(students[0]);  // '민수'
console.log(students[1]);  // '영희'
console.log(students[2]);  // '철수'
// 순서를 기억하는 자료형이기 때문에, 데이터를 순차적으로 저장하고 접근하기에 적합합니다.

// 배열과 순서 정보의 중요성
// - 첫 번째 값만 출력
// - 특정 위치의 값만 변경
// - 원하는 값이 몇 번째에 있는지 확인

// 배열 길이 확인 - length 속성(property)
// - 배열에는 요소의 개수를 알려주는 length라는 속성(property)이 있습니다.
// - 배열 이름 뒤에 .length를 붙이면 배열이 몇 개의 요소를 가지고 있는지 확인할 수 있습니다.
const fruits = ['사과', '바나나', '딸기'];

console.log(fruits.length); // 3
// - length는 배열에 '저장된 값의 개수'를 의미합니다.
// - 배열의 '마지막 인덱스'는 항상 `length - 1`입니다.
// - 예: 위 예제에서는 마지막 값인 '딸기'의 인덱스는 `2`입니다.

// 인덱스 활용 예
const colors = ['빨강', '초록', '파랑'];

colors[1] = '노랑'; // 두 번째 값을 '노랑'으로 바꿈

console.log(colors[1]); // 출력: '노랑'
// - 인덱스를 이용하면 값을 읽는 것뿐만 아니라 '수정하는 것도 가능'합니다.
// - 이처럼 배열은 '순서대로 접근할 수 있기 때문에,' 데이터 관리가 쉽고 효율적입니다.

// 빈 배열 확인하기
const emptyArr = [];

if (emptyArr.length === 0) {
  console.log("배열이 비어 있습니다.");
} else {
  console.log("배열에 요소가 있습니다.");
}
// - 배열의 길이가 `0`이라는 것은 '요소가 하나도 없다는 의미'입니다.
// - 이처럼 `length`는 단순한 길이 확인을 넘어서 '조건문과 함께 배열 상태를 확인하는 데에도' 유용하게 활용됩니다.


// 배열에서 특정 요소의 위치 찾기 (indexOf())
const students1 = ['민수', '영희', '철수'];
const studentName = '영희';

const index = students1.indexOf(studentName);
console.log(`'${studentName}'의 인덱스는 ${index}입니다.`); 
// 출력: '영희'의 인덱스는 1입니다.
// - `indexOf()`는 배열 안에서 해당 값이 처음 등장하는 위치(인덱스)를 반환합니다.
// - 요소가 존재하지 않으면 `-1`을 반환합니다.
// - 단순한 값 검색에 적합합니다.


// ㅇ 반복문으로 배열의 모든 요소 순회하기
// 프로그래밍에서 배열을 사용할 때 가장 자주 하는 작업 중 하나는 배열의 모든 요소를 처음부터 끝까지 하나씩 처리하는 것입니다. 이 작업은 for문과 배열의 length 속성을 함께 사용하면 아주 간단하게 구현할 수 있습니다.

const students2 = ['민수', '영희', '철수'];

// 1. 반복문으로 모든 학생 출력하기
for (let i = 0; i < students2.length; i++) {
    console.log(`${i+1}번째 학생: ${students2[i]}`);
}

// 2. 특정 학생 찾기
let findStudent = '영희';
let index1 = students2.indexOf(findStudent);
console.log(`${findStudent}는 ${index1}번 위치에 있습니다`);

// - `students.length`는 배열의 전체 길이(요소 개수)를 나타냅니다.
// - `i`는 인덱스 역할을 하며, 0부터 시작해서 하나씩 증가합니다.
// - `students[i]`는 배열의 각 위치에 있는 값을 꺼냅니다.
// - `${i + 1}`을 사용하면 사용자에게 더 친숙한 "1번째, 2번째"와 같은 표현이 됩니다.
// for (let i = 0; i < 배열.length; i++) 형태는 JavaScript에서 자주 등장하는 기본 반복 패턴입니다.

// ㅇ 배열 꼭 기억하기
// 1. **인덱스는 0부터 시작한다는 것을 기억하세요.**
//     - `array[0]`은 첫 번째 요소입니다. 실수로 1부터 시작한다고 착각하면 의도와 다른 값을 불러오게 됩니다.
// 2. **배열의 마지막 인덱스는 `length - 1`입니다.**
//     - `length`는 배열의 요소 개수입니다. **마지막 인덱스**는 `length - 1`입니다.
// 3. **존재하지 않는 인덱스를 호출하면 `undefined`가 반환됩니다**
//     - `array[10]`처럼 존재하지 않는 인덱스를 호출하면 오류는 나지 않지만 `undefined`가 반환됩니다.

// ================ 실습 코드 ===========================
// 🛒 배열과 인덱스를 활용한 장바구니 실습
// 1. 장바구니 초기화
// - 사과, 바나나, 딸기를 담은 배열 선언

// 2. 장바구니 목록 출력
// - 배열의 길이를 이용해 전체 상품 수 출력
// - 반복문을 사용해 각 상품을 번호와 함께 출력

// 3. 두 번째 상품을 변경해 보기
// - 인덱스를 사용해 '바나나'를 '오렌지'로 변경

// 4. 수정된 장바구니 출력
// - 배열의 길이 출력
// - 반복문으로 다시 모든 상품 출력

// 5. 장바구니 비어 있는지 확인
// - length가 0인지 확인하여 조건문으로 메시지 출력

// 6. 특정 상품 위치 찾기
// - '딸기'가 배열의 몇 번째에 있는지 indexOf로 확인
// - 결과를 사용자에게 출력

console.log('=========실습1========')
// 1. 장바구니 초기화
const cart = ['사과', '바나나', '딸기'];

// 2. 장바구니 목록 출력 (1.사과 2.바나나 ...)
console.log('[장바구니 목록]');
console.log(`총 ${cart.length}개의 상품이 담겨 있습니다.`);

for (let i = 0; i < cart.length; i++) {
  console.log(`${i+1}. ${cart[i]}`);
}

// 3. 두 번째 상품을 변경해 보기
cart[1] = '오렌지';

console.log('\n[수정된 장바구니 목록]');
console.log(`총 ${cart.length}개의 상품이 담겨 있습니다.`);

// 4. 수정된 장바구니 출력하기
for (let i = 0; i < cart.length; i++) {
  console.log(`${i+1}. ${cart[i]}`);
}

// 5. 장바구니가 비어 있는지 확인
if (cart.length === 0) {
  console.log('❌ 장바구니가 비어 있습니다.');
} else {
  console.log('🛒 장바구니에 상품이 있습니다.');
}

// 6. 특정 상품 위치 찾기 (딸기)
const itemToFind = '딸기';
const index2 = cart.indexOf(itemToFind);

if (index2 !== -1) {
  console.log(`\n${itemToFind}는 장바구니의 ${index2 + 1}번째에 있습니다.`);
} else {
  console.log(`\n${itemToFind}는 장바구니에 없습니다.`);
}
// ==========================================================

// 2. 목표 : Array.isArray를 사용하여 주어진 값이 배열인지 여부를 기억할 수 있다

// '우리는 어떤 값이 배열인지 정확하게 판별할 수 있어야 합니다.'
// JavaScript에서는 문자열이나 객체처럼 배열과 유사한 형태를 가진 값들이 존재하기 때문에, 겉모습만으로는 배열 여부를 정확히 판단하기 어렵습니다. 
// 이러한 경우에는 `Array.isArray()` 메서드를 활용하여 주어진 값이 실제 배열인지 아닌지를 명확하게 확인할 수 있습니다. 프로그래밍에서는 '값의 자료형'에 따라 처리 방식이 달라지므로, 배열인지 여부를 정확하게 구분하는 것이 매우 중요합니다.
// 특히 조건 분기나 사용자 입력 처리 등에서 유용하게 사용됩니다.

// ㅇ Array.isArray()
// - 주어진 값이 '배열인지 아닌지를 판별하는 메서드'입니다.
// - 배열처럼 보이는 값이 실제로 배열인지 확인할 때 사용하며, `true` 또는 `false`를 반환하여, 값이 실제 배열일 때만 `true`를 반환합니다.
Array.isArray([1, 2, 3]);       // true
Array.isArray('hello');         // false
Array.isArray({ a: 1 });        // false

// ㅇ 기본구조 : Array.isArray(값)
// - 값은 배열인지 확인하고 싶은 대상입니다.
// - 해당 값이 배열이라면 `true`, 배열이 아니라면 `false`를 반환합니다.

// ㅇ Array.isArray()가 필요한 이유
// - JavaScript에서 배열은 `typeof` 연산자로는 정확히 구분할 수 없습니다. 예를 들어 `typeof [1, 2, 3]`을 실행하면 결과는  `“object”`로 출력됩니다. 이처럼 배열은 내부적으로 객체로 처리되기 때문에, 일반 객체와 구분하기 어렵습니다.
// - 따라서 특정 값이 '실제로 배열인지 판별하고자 할 때는' `Array.isArray()` 메서드를 사용하는 것이 가장 정확하고 안전한 방법입니다

// 1. 배열처럼 생긴 문자열은 실제 배열이 아닙니다.
console.log(Array.isArray('[1, 2, 3]')); // false

// 2. null, 객체, 함수는 모두 false 를 반환합니다.
console.log(Array.isArray(null));        // false
console.log(Array.isArray({}));          // false
console.log(Array.isArray(function(){}));// false

// 3. typeof와 Array.isArray는 구분됩니다.
console.log (typeof [1, 2, 3]);        // "object"
console.log(Array.isArray([1, 2, 3])); // true

// **`Array.isArray()`는 값이 배열인지 여부를 정확히 확인해야 할 때 가장 적합한 메서드입니다.**
// 특히 데이터의 형태가 명확하지 않거나, 배열처럼 보이는 값(예: 객체, 문자열, `null`)을 구분해야 할 때 유용합니다. 
// - API 응답을 처리하는 경우
// - 사용자 입력 값의 타입을 확인해야하는 경우
// - 조건 분기 로직에서 배열 여부에 따라 다른 처리를 해야 하는 경우

// ======================실습2============================
// 1. 숫자 - 예시 값: 42
// 2. 문자열 - 예시 값: 'hello'
// 3. 배열 - 예시 값: [1, 2, 3]
// 4. 빈 배열 - 예시 값: []
// 5. 객체 - 예시 값: { a: 1 }
// 6. undefined
// 7. null
// 8. 함수 -  예시 값: function () {}
// 9. 배열처럼 생긴 문자열 - 예시 값: '[1, 2, 3]'
// 10. new Array()로 생성된 배열 - 예시 값: new Array(2)
console.log('========실습2=========');
console.log('1. 숫자:', Array.isArray(42));
console.log('2. 문자열:', Array.isArray('hello'));
console.log('3. 배열:', Array.isArray([1, 2, 3]));
console.log('4. 빈 배열:', Array.isArray([]));
console.log('5. 객체:', Array.isArray( { a: 1 } ));
console.log('6. undefined:', Array.isArray(undefined));
console.log('7. null:', Array.isArray(null));
console.log('8. 함수:', Array.isArray(function (){}));
console.log('9. 배열처럼 생긴 문자열:', Array.isArray('[1, 2, 3]'));
console.log('8. new Array()로 생성된 배열:', Array.isArray(new Array(2)));
// let a = new Array(2, 3, 4, 'fff');
// console.log(a);
// ========================================================================

// 3. 목표 : pop(), push(), unshift(), shift() 등의 메서드를 사용하여 배열 요소를 추가 또는 삭제할 수 있다
// - `push()` : 배열의 끝에 요소를 추가
// - `pop()` : 배열의 끝 요소를 제거
// - `unshift()` : 배열의 앞에 요소를 추가
// - `shift()` : 배열의 앞 요소를 제거

// ㅇ 배열 끝에 요소 추가: push()
const fruits2 = ['사과', '바나나'];
const newLength = fruits2.push('오렌지');

console.log(fruits2);     // ['사과', '바나나', '오렌지']
console.log(newLength);  // 3
// - 배열의 마지막에 요소를 추가합니다.
// - 반환값은 '변경된 배열의 길이'입니다.

// ㅇ 배열 끝에서 요소 제거: pop()
const fruits3 = ['사과', '바나나', '오렌지'];
const removed = fruits3.pop();

console.log(fruits3);   // ['사과', '바나나']
console.log(removed);  // '오렌지'
// - 배열의 마지막 요소를 제거합니다.
// - 반환값은 '제거된 요소'입니다.

// ㅇ 배열 앞에 요소 추가: unshift()
const fruits4 = ['사과', '바나나'];
const newLength1 = fruits4.unshift('포도');

console.log(fruits4);     // ['포도', '사과', '바나나']
console.log(newLength1);  // 3
// - 배열의 첫 번째 위치에 요소를 추가합니다.
// - 반환값은 '변경된 배열의 길이'입니다.

// ㅇ 배열 앞에서 요소 제거: shift()
const fruits5 = ['포도', '사과', '바나나'];
const removed1 = fruits5.shift();

console.log(fruits5);   // ['사과', '바나나']
console.log(removed1);  // '포도'
// - 배열의 첫 번째 요소를 제거합니다.
// - 반환값은 '제거된 요소'입니다.

// 예를 들어, push()나 pop()을 사용하면 기존 배열 자체가 바뀝니다. 반면, slice() 같은 메서드는 원본을 그대로 두고 새로운 배열을 반환합니다.

let arr = ['a', 'b', 'c'];
let newArr = arr.slice(0, 2); // 0번부터 2번 인덱스 이전까지 복사

console.log(newArr); // ['a', 'b']
console.log(arr);    // ['a', 'b', 'c'] → 원본 배열
// slice()는 일정 범위의 요소를 복사한 새 배열을 반환하며, 원본 배열에는 아무런 영향을 주지 않습니다.

// !! 주의사항
// - `push()`와 `unshift()`는 수정된 **배열의 길이**를 반환합니다.
// - `pop()`과 `shift()`는 배열에서 **제거된 요소**를 반환합니다.
// - **빈 배열**에서 `pop()`이나 `shift()`를 사용하면 `undefined`를 반환합니다.
// - `push()`, `unshift()`, `pop()`, `shift()`는 원본 배열을 직접 수정하므로, 수정된 배열을 새로운 변수에 할당할 필요가 없습니다.

// ==================실습3==============================
// 1. 빈 배열로 장바구니(cart)를 만든다.
// 2. 장바구니에 상품을 3개 추가한다 (push)
// 3. 현재 장바구니를 출력한다
// 4. 마지막 상품을 꺼낸다 (pop)
// 5. 꺼낸 상품과 장바구니 상태를 출력한다
// 6. 장바구니 맨 앞에 새 상품을 추가한다 (unshift)
// 7. 장바구니 맨 앞의 상품을 꺼낸다 (shift)
// 8. 꺼낸 상품과 최종 장바구니 상태를 출력한다

// 🛒 배열 메서드 실습: 장바구니 담기와 꺼내기

// 1. 장바구니(cart) 배열을 만든다.
const cart1 = [];

// 2. 상품을 3개 추가한다. ("사과", "바나나", "딸기")
cart1.push('사과', '바나나', '딸기');

// 3. 현재 장바구니 내용을 출력한다.
console.log('현재 장바구니:', cart1);

// 4. 장바구니에서 마지막에 담은 상품을 꺼낸 후 removedItem 변수에 할당한다.
const removedItem = cart1.pop();

// 5. 꺼낸 상품과 현재 장바구니 내용을 출력한다.
console.log('꺼낸 상품:', removedItem);
console.log('업데이트된 장바구니:', cart1);

// 6. 장바구니 맨 앞에 "포도"를 추가한다.
cart1.unshift('포도');
console.log('포도를 앞에 추가한 장바구니:', cart1);

// 7. 장바구니 맨 앞 상품을 꺼내고, 꺼낸 상품을 firstRemoved 변수에 할당한다.
const firstRemoved1 = cart1.shift();
console.log('맨 앞에서 꺼낸 상품:', firstRemoved1);
console.log('최종 장바구니 상태:', cart1);
// =========================================================================

// 4. slice() 메서드를 사용하여 배열 요소 중 일부를 복사하여 새로운 배열을 생성하고 활용할 수 있다.

// `slice()`는 배열에서 원하는 구간을 잘라내어 '새로운 배열을 반환'합니다. 마치 `ctrl + c`처럼 원본은 그대로 두고 필요한 부분만 복사할 수 있죠.

// 이 메서드를 사용하면 '원본 배열을 손상시키지 않고' 필요한 데이터만 뽑아 다양한 상황에서 유연하게 활용할 수 있습니다.

// '부분 복사 + 원본 보호, 두 가지를 동시에 만족시키는 강력한 도구입니다.'

// ㅇ  배열 `slice()` 메서드 이해하기
// - `slice()` 메서드는 배열의 특정 부분을 추출하여 새로운 배열을 반환합니다. 원본 배열은 변경되지 않습니다.
// - `slice(시작 인덱스, 끝 인덱스)`로 사용합니다.
// - 끝 인덱스 위치의 요소는 포함되지 않습니다. 즉, `slice(시작 인덱스, 끝 인덱스)` 메서드는 시작 인덱스부터 끝 인덱스 바로 이전 위치의 요소까지만 추출합니다. 끝 인덱스에 있는 요소 자체는 결과 배열에 포함되지 않습니다.
console.log('========================')
const fruits10 = ['사과', '바나나', '오렌지', '포도', '키위'];
const selected = fruits10.slice(1, 3);
console.log(selected);  // ['바나나', '오렌지']
console.log(fruits10);    // ['사과', '바나나', '오렌지', '포도', '키위']

// ㅇ 끝 인덱스 생략하기
// - 끝 인덱스를 생략하면 인덱스 2부터 배열의 끝까지 추출합니다.
// const fruits10 = ['사과', '바나나', '오렌지', '포도', '키위'];
const selected2 = fruits10.slice(2);
console.log(selected2);  // ['오렌지', '포도', '키위']

// ㅇ 음수 인덱스 사용하기
// - 음수 인덱스는 배열의 끝에서부터 위치를 나타냅니다.
// -slice(-2) => 배열의 끝 요소(-1)부터 -2까지 출력
// - `-1`은 마지막 요소를 의미합니다.
// const fruits10 = ['사과', '바나나', '오렌지', '포도', '키위'];
const selected3 = fruits10.slice(-2);
console.log(selected3);  // ['포도', '키위']

// ㅇ 배열 전체 복사하기
// slice() 메서드는 전달인자를 아무것도 주지 않고 호출하면 전체 배열을 복사합니다.
// 이때 반환되는 배열은 새로운 메모리 주소를 가진 독립적인 배열입니다.
const fruits11 = ['사과', '바나나', '오렌지'];
const copiedFruits = fruits11.slice(); // 전체 복사
console.log(fruits11);       // ['사과', '바나나', '오렌지']
console.log(copiedFruits); // ['사과', '바나나', '오렌지']
copiedFruits[0] = '포도';
console.log('비교===========')
console.log(fruits11);       // ['사과', '바나나', '오렌지']
console.log(copiedFruits); // ['포도', '바나나', '오렌지']

// 참고: 전개 연산자(Spread Syntax)를 사용한 복사
// - 배열 전체를 복사할 때는 다음과 같이 전개 연산자(...)를 사용할 수도 있습니다.
const copiedFruits2 = [...fruits11];
// - `slice()`와 마찬가지로 새로운 배열을 생성하며, 원본 배열과는 서로 영향을 주지 않습니다.
// - 자세한 내용은 전개 연산자(Spread Syntax) 학습 파트에서 더 알아보게 됩니다.

// !! 주의사항
// 1. '원본 배열을 변경하지 않는다'
//     - `slice()`는 항상 '새로운 배열을 반환'합니다.
//     - 추출 대상이 아닌 부분도 그대로 유지되며, 원본 배열에는 아무런 영향이 없습니다.
// 2. '끝 인덱스는 포함되지 않는다'
//     - `slice(start, end)` 형태로 사용하면, ' `start`부터 `end - 1`까지'의 요소만 포함됩니다.
//     - `end`에 해당하는 요소는 결과 배열에 포함되지 않으므로 주의해야 합니다.
// 3. '시작 인덱스가 배열 길이보다 크면 빈 배열을 반환한다'
//     - 예를 들어, 길이가 3인 배열에서 `slice(5)`를 실행하면 `[]`가 반환됩니다.
// 4. '전달 인자를 생략하면 배열 전체를 복사한다'
//     - `slice()`를 아무 인자 없이 호출하면 '배열 전체가 복사된 새로운 배열'이 생성됩니다.
//     - 이 복사본은 '원본 배열과는 다른 메모리 주소를 참조'하므로, 수정해도 원본에는 영향을 주지 않습니다.

// ** 참조(reference)란?
// 값 그 자체가 아니라, '그 값이 저장된 메모리의 위치(주소)'를 가리키는 정보를 말합니다. 쉽게 말해, '데이터를 직접 들고 있는 것이 아니라, 그 데이터가 어디 있는지를 알려주는 길잡이'라고 생각하면 됩니다.

// JavaScript에서는 '배열, 객체, 함수'처럼 복잡한 구조를 가진 값들이 '참조형 자료형(reference type)'에 해당합니다. 이들은 변수에 실제 값이 아닌 '메모리 주소(참조)'가 저장되므로, 같은 객체를 여러 변수가 공유할 수 있고, 하나를 수정하면 다른 쪽에도 영향을 줄 수 있습니다.

// 이러한 특성은 숫자, 문자열 등 '원시 자료형(primitive type)'과 구별되는 중요한 차이이며, 이후 콘텐츠에서 더 자세히 다룰 예정입니다.

// slice() 정리
// - `slice(시작, 끝)`은 시작 인덱스부터 끝 인덱스 직전까지 복사합니다.
// - 인덱스를 생략하면 전체 배열을 복사합니다.
// - 음수 인덱스를 사용하면 뒤에서부터 복사할 수 있습니다.
// - 복사된 배열은 원본과 다른 주소를 참조하므로 서로 영향을 주지 않습니다.
// - 배열 전체 복사에는 `slice()`뿐만 아니라 전개 연산자(`...`)도 사용할 수 있습니다.

// =============실습3===================================
// 🍔 햄버거 주문 수정 시스템 의사코드

// 1. 오늘 주문된 햄버거 목록을 배열로 선언한다.
// ['치킨버거', '불고기버거', '상하이버거', '새우버거']
// 2. 원본 배열을 slice()를 사용해서 복사한다.
// 3. 복사한 배열에서 '상하이버거'가 있는 위치(index)를 찾는다.
// 4. index가 -1이 아니라면, 해당 위치의 값을 '데리버거'로 수정한다.
// 5. 원본 배열과 수정된 배열을 각각 console.log로 출력한다.

// 1. 오늘 주문된 햄버거 목록을 배열로 선언한다.
const orders = ['치킨버거', '불고기버거', '상하이버거', '새우버거'];

// 2. 원본 배열을 slice()를 사용해서 복사한다.
const correctedOrders = orders.slice();

// 3. 복사한 배열에서 '상하이버거'가 있는 위치(index)를 찾는다.
const arrayIndex = correctedOrders.indexOf('상하이버거');

// 4. index가 -1이 아니라면, 해당 위치의 값을 '데리버거'로 수정한다.
if(arrayIndex !== -1){
    correctedOrders[arrayIndex] = '데리버거';
}

// 5. 원본 배열과 수정된 배열을 각각 console.log로 출력한다.
console.log('📋 원본 주문 목록:', orders);
console.log('✅ 수정된 주문 목록:', correctedOrders);
// ===========================================================================

// 5. 목표 : 배열을 효율적으로 다루기 위한 메서드의 종류와 기능을 나열할 수 있다.

// '배열은 단순히 값을 나열하는 것에서 그치지 않습니다.
// 필요한 값을 찾고, 합치고, 순서를 바꾸고, 원하는 형태로 가공하는 등 다양한 작업에 활용됩니다.'

// 이런 작업을 빠르고 정확하게 처리하려면, 배열을 조작할 수 있는 다양한 메서드를 제대로 이해하고 활용할 줄 아는 것이 중요합니다. 이번에는 배열을 더욱 '유연하고 효율적으로 다룰 수 있는 메서드들'을 배워보겠습니다.

// 이 메서드들은 실무에서도 매우 자주 사용되며, 코드를 더 짧고 명확하게 만들어 줍니다.

// ㅇ 배열을 효율적으로 다루는 메서드
// - splice() : 배열의 중간에 요소를 추가하거나 제거 / 원본 변경O
// - includes() : 배열에 특정 값이 존재하는지 확인 / 원본 변경X
// - concat() : 두 개 이상의 배열을 하나로 합침 / 원본 변경X
// - reverse() : 배열의 순서를 뒤집음 / 원본 변경O
// - join() : 배열을 문자열로 변환 / 원본 변경X
// - fill() : 배열의 모든 요소를 특정 값으로 채움 / 원본 변경O


// ㅇ 배열 중간에서 요소 추가, 제거, 교체:  splice(start, deleteCount, ...items)
// - start : 인덱스 시작점
// - deleteCount : 삭제할 개수
// - items : 삽입할 값들
console.log('=========================');
let colors2 = ['red', 'blue', 'green'];
colors2.splice(1, 1, 'yellow');   // 1번 인덱스부터 1개 제거하고 'yellow' 추가

console.log(colors2);             // ['red', 'yellow', 'green']
// - 배열에서 원하는 위치의 '요소를 삭제, 변경, 추가'할 수 있습니다.
// - 배열의 구조를 직접 바꾸기 때문에 ✅ '원본 배열이 변경됩니다.'


// ㅇ 배열에 특정 값이 포함되어 있는지 확인하는 경우: includes(value)
// - value : 찾고자 하는 값
const animals = ['dog', 'cat', 'rabbit'];

console.log(animals.includes('cat'));       // true
console.log(animals.includes('elephant'));  // false
// - 배열 내에 '특정 값이 포함되어 있는지를 확인'하여, 그 결과를 '`true`' 또는 '`false`'로 반환합니다.
// - 조건 분기 처리에 자주 사용되며, ❌ '원본 배열은 변경되지 않습니다.'


// ㅇ 배열을 합쳐서 새로운 배열 만들기: concat(...value)
// - value : 합치고자 하는 배열 or 값들
let a = [1, 2];
let b = [3, 4];
const combined = a.concat(b);

console.log(combined);
// - 두 개 이상의 배열을 하나로 합쳐서 새 배열을 반환합니다.
// - 기존 배열(`a`,`b`)은 그대로 유지되며, 결과는 새로운 배열(`combined`)로 만들어집니다.


// ㅇ 배열의 순서를 뒤집기: reverse()
let numbers = [1, 2, 3];
numbers.reverse();

console.log(numbers);   // [3, 2, 1]
// - 배열 요소들의 순서를 반대로 바꿉니다.
// - ✅ 원본 배열 자체가 변경됩니다.


// ㅇ 배열을 문자열로 합치기: join(separator) 
// - separator : 요소 사이에 넣을 문자열 (구분자)
let words = ['Hello', 'World'];

console.log(words.join(' '));    // Hello World
console.log(words.join('-'));    // Hello-World
// - 배열의 모든 요소를 연결해서 '하나의 문자열'로 반환합니다.
// - 사이사이 어떤 구분자(`,`, `‘ ’` , `-`)를 넣을지 지정할 수 있습니다.
// - '❌ 원본 배열은 변경되지 않습니다.'


// ㅇ 배열의 모든 요소를 같은 값으로 채우기: fill(value, start, end) 
// - value : 채울 값
// - start : 인덱스 시작점
// - end : 채우기 종료 시점 (지정 인덱스는 포함X)
let arr2 = [0, 0, 0, 0];
arr2.fill(7, 1, 3); // 1번~2번 인덱스를 7로 채움

console.log(arr2);  // [0, 7, 7, 0]
// - 배열의 특정 범위를 '지정한 값으로 채웁니다.'
// - 초기화나 샘플 데이터 제작 등에 유용하지만, ✅ '원본 배열이 직접 변경됩니다.'


// !! 주의사항
// - '`splice()`', '`reverse()`', '`fill()`' 은 '원본 배열을 직접 수정합니다.'
//     - 기존 배열을 보존하고 싶다면 '복사본'을 만든 뒤 사용하는 것이 좋습니다.
// - '`includes()`', '`concat()`', '`join()`' 등은 '원본 배열을 변경하지 않고', '새로운 값을 반환'합니다.
//     - '`concat()`'의 경우 결과 배열을 변수에 저장하지 않으면 기존 배열은 그대로 유지됩니다.
// - '`includes()`'는 값이 정확히 일치해야만 '`true`'를 반환합니다.
//     - 숫자와 문자열처럼 타입이 다르면 '`false`', 객체나 배열은 참조값이 다르면 '`false`'가 됩니다.
// - '`join()`'은 배열을 '문자열'로 변환하므로, 그 결과에는 '배열 메서드를 적용할 수 없습니다.'
// - '`fill()`'은 배열의 '모든 요소'를 '동일한 값'으로 채웁니다.
//     - 배열 같은 참조형 값을 넣으면 '모든 요소가 같은 객체를 가리키게 되므로' 주의가 필요합니다.


const arr22 = new Array(3).fill({ name: "Alice" });

console.log(arr22);
// [ { name: 'Alice' }, { name: 'Alice' }, { name: 'Alice' } ]

arr22[0].name = "Bob";
console.log(arr22);
// [ { name: 'Bob' }, { name: 'Bob' }, { name: 'Bob' } ] ⚠️ 전부 바뀜

// - **`{ name: "Alice" }`**는 **하나의 객체 주소(참조값)**를 가지고 있고, **`fill()`**이 그 **하나의 객체 주소를 3번 복사하여** 채웁니다.
// - 그래서 `arr[0]`, `arr[1]`, `arr[2]`는 모두 **같은 객체를 가리키고 있습니다**.
// - 하나의 요소를 바꾸면 **모두 바뀝니다.**

// ======================실습4=================================
// 1. 좌석 초기화 (fill)
let seats = ['비어있음', 'ko','kang','비어있음']
console.log('초기 좌석 상태:', seats);

seats.fill('비어있음'); 
console.log('바뀐 좌석 상태:', seats); //비어있음, 비어있음, 비어있음, 비어있음

// 2. 좌석 3번, 4번에 예약자 추가 (splice)
seats.splice(2, 2, 'kwon', 'hyun'); //2번 인덱스부터 2개 삭제 후 추가
console.log('kwon, hyun 예약 후:', seats);

// 3. 예약 확인 (includes)
const isCharlieReserved = seats.includes('lee');
console.log('lee 예약 여부:', isCharlieReserved);

// 4. 단체 예약 추가 (concat)
const group = ['ahn', 'yoon'];
const updatedSeats = seats.concat(group);
console.log('단체 예약 포함 좌석 상태:', updatedSeats);

// 5. 입장 순서 변경 (reverse)
const reversedSeats = updatedSeats.slice().reverse(); // 원본 유지 위해 복사 후 revese
console.log('입장 순서 (역순):', reversedSeats);

// 6. 문자열 포맷 출력 (join)
const entranceOrder = reversedSeats.join(' > ');
console.log('최종 입장 순서:', entranceOrder);
// ========================================================

// 6. 목표 : for문을 사용하여 배열의 모든 요소를 순회하고, 각 요소에 대해 원하는 작업을 수행하는 코드를 구현할 수 있다.


// ㅇ for문 + 배열 순회의 기본 구조
// - 배열은 여러 개의 데이터를 담는 자료형입니다. 
// for문을 사용하면 배열의 각 요소를 처음부터 끝까지 순서대로 꺼내 작업을 수행할 수 있습니다.
// for (let i = 0; i < 배열.length; i++) {
//   // 배열[i]를 활용한 작업
// }


// ㅇ for문을 활용한 배열 순회 실전 예제
// 1. 배열의 모든 요소 출력하기
console.log('==============');
const colors3 = ['red', 'green', 'blue'];

for (let i = 0; i < colors3.length; i++) {
  console.log(`색상: ${colors3[i]}`);
}
// **출력 결과**
// 색상: red
// 색상: green
// 색상: blue

// 2. 숫자 배열에서 합계 구하기
const scores = [90, 85, 100, 70];
let sum = 0;

for (let i = 0; i < scores.length; i++) {
  sum += scores[i];
}

console.log('총합:', sum); // 총합: 345

// 3. 특정 조건을 만족하는 값 찾기
const scores2 = [100, 76, 89, 40, 95, 55];

for (let i = 0; i < scores2.length; i++) {
  if (scores2[i] < 60) {
    console.log(`재시험 대상 점수: ${scores2[i]}`);
  }
}
// **출력 결과**
// 재시험 대상 점수: 40
// 재시험 대상 점수: 55

// ### ⚠️ 주의 사항
// 1. 인덱스는 항상 `0`부터 시작합니다 → 배열의 첫 번째 요소는 `arr[0]`입니다.
// 2. 조건식에서 `.length` 를 사용하면 배열 크기만큼 정확히 반복할 수 있습니다.
// 3. 인덱스(`i`)만 사용하거나 `arr[i]`를 혼동하여 값을 잘못 사용하는 경우를 주의해야 합니다.
//     - 예시: `arr[i] % 2`는 올바른 접근이지만, `i % 2`는 원하는 결과가 아닐 수 있습니다.
// 4. 배열을 순회할 때는 '원본 배열이 변경'될 수도 있으므로 구조를 잘 이해하고 사용하셔야합니다.


// ====================실습=======================================

// 1. 도넛 이름 배열
const donuts = ['초코도넛', '딸기도넛', '바나나도넛', '말차도넛'];

// 2. 각 도넛의 판매 수량 배열 (donuts 배열과 같은 순서)
const sales = [12, 8, 5, 10];

// 3. 각 도넛의 재고 수량 배열 (donuts 배열과 같은 순서)
const stocks = [8, 3, 12, 6];

// 4. 도넛 이름 출력 (for문 사용)
for (let i = 0; i < donuts.length; i++) {
    console.log(`오늘의 도넛 : ${donuts[i]}`);
}
// 5. 판매 수량 합계 계산 (for문 사용)
let totalSales = 0;
for (let i = 0; i < sales.length; i++) {
    totalSales += sales[i];
}
console.log(`총 판매 수량: ${totalSales}개`);

// 6. 재고 5개 미만 도넛 이름 출력 (for문, if문 사용)
for (let i = 0; i < donuts.length; i++) {
    if (stocks[i] < 5) {
        console.log(`주문 필요 도넛 : ${donuts[i]}`);
    }
}
// ========================================================

// 7. 목표 : for문 내부에 if문을 사용하여 배열의 모든 요소 중 조건에 맞는 요소에 대해서만 원하는 작업을 수행하는 코드를 구현할 수 있다.

// ㅇ 조건을 만족하는 값만 처리하는 경우 : for문 내부 if문
// - for 반복문 : 배열 등의 각 요소를 순회하는 역할
// - if 조건문 : for문 내부에서 현재 요소가 특정 조건을 만족하는지 검사

// 1. 배열에서 짝수만 출력하기
const numbers2 = [1, 2, 3, 4, 5];
for (let i = 0; i < numbers2.length; i++) {
  if (numbers2[i] % 2 === 0) {
    console.log(numbers2[i]); // 짝수만 출력
  }
}

// 2. 합계, 카운트 등 누적 작업
const scores3 = [10, 20, 30, 40];
let sum2 = 0;
for (let i = 0; i < scores3.length; i++) {
  if (scores3[i] >= 30) {
    sum2 += scores3[i];
  }
}
console.log(sum2); // 70

// ## ⚠️ 주의 사항
// 1. '조건문이 길어지지 않도록 주의한다.'
//     - `if` 안의 조건식이 '지나치게 길거나 중첩되면' 코드를 이해하기 어렵습니다.
//     - 가독성이 떨어질 경우, '조건을 별도의 함수로 분리'하거나 '코드를 리팩토링'하는 것을 고려합니다.
// 2. '누적 변수는 반복문 전에 초기화한다.'
//     - 합계(`sum`), 개수(`count`) 등 누적 계산이 필요한 변수는 '반드시 `for`문 시작 전에 선언하고 초기화'해야 합니다.
//     - `for`문 안에서 초기화하면 '반복 시마다 값이 리셋되어' 최종 누적 결과를 얻을 수 없습니다.
// 3. '반복 중인 배열은 직접 수정하지 않는다.'
//     - `for`문으로 배열 순회 중 '`if` 조건에 따라 해당 배열 요소를 추가/삭제하면 예기치 않은 문제'가 발생할 수 있습니다.
//     - `요소 삭제` 시: '배열 길이가 줄고 인덱스가 밀려 일부 요소를 건너뛸 수 있습니다.'
//     - `요소 추가` 시: '경우에 따라 무한 루프에 빠질 수 있습니다.'
//     - 배열 수정이 필요하다면, '새 배열을 생성하거나 반복문을 역순으로 실행'하는 등의 대안을 사용합니다.


// ===========================실습==================================
// 주어진 책 판매 부수 목록에서 판매량이 500 이상인 책만 골라냅니다.

// bookSales 변수에 여러 책들의 판매 부수를 담은 데이터가 들어 있습니다.
const bookSales = [300, 850, 450, 1200, 200, 980, 600, 150];

// 여기에 코드를 작성하세요.
let bestsellerCandidates = [];
for (let i = 0; i < bookSales.length; i++) {
    if (bookSales[i] >= 500) {
        bestsellerCandidates.push(bookSales[i]);
    }
}
console.log('베스트셀러 후보 판매 부수 목록:', bestsellerCandidates.join(','));
// ===========================================================================

// 8. 목표 : for...of 문을 사용하여 배열의 모든 요소를 순회하고, 가독성을 높인 코드를 구현할 수 있다.

// 배열이나 문자열처럼 '순회 가능한 데이터'가 있을 때, 각 요소를 하나씩 순서대로 처리하고 싶다면 `for...of`문을 사용해보세요.

// 예를 들어,

// - 배열 안에 있는 값을 하나씩 출력할 때
// - 문자열의 각 글자를 순서대로 처리할 때
// - 장바구니에 담긴 상품 목록을 보여줄 때

// 이처럼 `for...of`문은 '반복 가능한 값들을 순서대로 처리'할 때 코드를 간결하게 작성할 수 있습니다.


// ㅇ for ... of 문
// JavaScript에서 `for…of` 문은 **배열이나 문자열과 같은 반복 가능한(iterable) 객체의 요소를 하나씩 순회**할 때 사용합니다.
// 반복 가능한 객체는 대표적으로 다음과 같은 것들이 있습니다.
// - `Array`, `String`, `Map`, `Set`, `arguments`
// `for…of`문은 배열의 인덱스를 직접 다루지 않아서 코드가 더 간단하고 직관적입니다. 또한 반복 대상의 각 값 자체를 순서대로 처리하며 `break`, `continue`와 함께 사용할 수 있어 제어가 쉽습니다.

// for (variable of iterable) {
    //   실행할 코드;
    // }

// - `variable`: 반복 중 `iterable`의 각 요소가 이 변수에 할당됩니다.
// - `iterable`: 반복 가능한 객체입니다.
//     - ex. `[1,2,3]`
// 각 반복마다 반복 가능한 객체(`iterable`)의 값을 하나씩 꺼내어 지정된 변수(`variable`)에 할당합니다.


// ㅇ 배열 순회
let iterable = [10, 20, 30];

for (let value of iterable) {
  console.log(value);
} // 10 / 20 / 30 차례대로 출력

// ㅇ 문자열 순회
let iterable1 = "ABCDEFG";

for (let value of iterable1) {
  console.log(value);
}

// ㅇ break과 사용하기
// - 반복문 안에서 특정 조건을 만족할 때, 반복 자체를 완전히 종료시킵니다.
const fruits7 = ["사과", "바나나", "포도", "복숭아", "딸기"];

for (const fruit of fruits7) {
  if (fruit === "포도") {
    break; // 반복 종료
  }
  console.log(fruit);
}
// "사과"
// "바나나"


// ㅇ continue와 같이 사용하기
// - 반복문 안에서 조건에 따라 현재 반복을 건너뛰고 다음 반복으로 넘어가도록 합니다.
const text = "김 오 즈";

for (const char of text) {
  if (char === " ") {
    continue; // 공백은 건너뛰고 다음 반복으로 넘어감
  }
  console.log(char);
}
// 김
// 오
// 즈

// !! 기억하기
// - `continue`: '이번 반복만 건너뛰고 다음 반복을 계속함'
// - `break`: '반복문 전체를 즉시 종료함'

// ㅇ for..of문과 foo..in문
// - `for…of` 문은 반복 가능한 객체의 '값(value)'을 순회합니다. 주로 배열, 문자열 등 값의 순회가 필요할 때 사용합니다.
// - `for…in` 문은 객체의 열거 가능한 '속성(key 또는 index)'을 문자열로 순회합니다. 주로 일반 객체의 속성을 순회할 때 사용하며, 배열 순회에는 권장되지 않습니다.

let iterable2 = '김오즈';

for (let i of iterable2) {
  console.log(i); // '김', '오', '즈' 
}

for (let i in iterable2) {
  console.log(i); // 0, 1, 2
}

// ## ⚠️ 주의 사항

// '1. `for...of` 문은 인덱스를 제공하지 않습니다.'

// - `for...of`문은 배열의 '값(value)'만 순회할 수 있고, '인덱스(index')는 제공하지 않습니다.
// - 인덱스가 필요하다면 다음과 같은 방법을 사용할 수 있습니다.
//     - `for`문
//     - `forEach`
//     - `array.entries()`와 `for...of`를 함께 사용
// 2. '객체는 `for...of`로 순회할 수 없습니다'
// - 객체는 기본적으로 '이터러블이 아니기 때문에' `for...of`문으로 순회할 수 없습니다.
    
//     객체를 순회하고 싶다면 아래 방법을 사용해야 합니다.
    
//     - `for...in` : 키 (속성명)을 하나씩 순회합니다.
//     - `Object.keys()` → 키 배열을 반환합니다.
//     - `Object.entries()` → [key, value] 쌍 배열을 반환합니다.
// 3. '`for…of`문과 `for…in`문을 헷갈리지 않도록 주의해야 합니다.'

// =======================실습====================================

// 주문한 메뉴 가격 목록
const itemPrices = [15000, 8500, 22000, 6000, 3500];

//여기에 코드를 작성하세요
// '🧾 계산 완료! 총 지불할 금액은 55000원 입니다.'

let totalAmount = 0; //총액 저장
for (let val of itemPrices) {
   totalAmount += val;
}

console.log(`계산 완료: 총 지불할 금액은 ${totalAmount.toLocaleString()}원 입니다.`);
// toLopcaleString 은 55000 > 55,000 으로 변환 해줌

// ==================================================================================


// 9. 목표 : 다중 반복문을 사용하여 중첩된 배열(2차원 배열 등)의 모든 요소를 순회하고 작업을 수행할 수 있다.

// '중첩 배열은 배열 안에 또 다른 배열이 포함된 구조를 말합니다.'

// 예를 들어, “좌석표처럼 행과 열로 구성된 데이터를 순서대로 출력하려면 어떻게 해야 할까?”와 같은 문제는 '각 행을 순회하면서,' 그 안에 있는 열도 다시 순회해야 하기 때문에 '반복문 안에 또 다른 반복문이 필요합니다.'

// 이처럼 반복문을 중첩해서 사용하면, 배열의 구조에 맞춰 모든 값을 빠짐없이 탐색할 수 있어 '2차원 데이터를 다루는 데 매우 효과적입니다.'


// ㅇ 중첩 배열 순회와 다중 반복문
// - JavaScript에서는 배열 안에 또 다른 배열이 있는 중첩 배열(nested array) 또는 2차원 배열을 자주 다루게 됩니다. 이때 각 요소에 접근하여 작업을 수행하기 위해서는 다중 반복문(nested loop)을 사용해야 합니다.
console.log('==========================');

// 예시 1
const arr1 = [[1, 2], [3, 4], [5, 6]];

for (let i = 0; i < arr1.length; i++) {
  for (let j = 0; j < arr1[i].length; j++) {
    console.log(`행 ${i}, 열 ${j}: ${arr1[i][j]}`);
  }
}

// 예시 2
const seats2 = [
  ['A1', 'A2', 'A3'],
  ['B1', 'B2', 'B3'],
  ['C1', 'C2', 'C3']
];

for (let i = 0; i < seats2.length; i++) {
  for (let j = 0; j < seats2[i].length; j++) {
    console.log(`좌석 번호: ${seats2[i][j]}`);
  }
}

// 예시 3
const board = [
  [5, 10, 15],
  [20, 25, 30],
  [35, 40, 45]
];

let total = 0;

for (let i = 0; i < board.length; i++) {
  for (let j = 0; j < board[i].length; j++) {
    total += board[i][j];
  }
}
console.log(`총 점수: ${total}`); // 총 점수: 225


// ㅇ for…of 문 활용하기 (다중배열)
const matrix = [
  [10, 20],
  [30, 40],
  [50, 60]
];

for (row of matrix) {
    for (value of row) {
        console.log(value);
    }
}
// 10
// 20
// ..
// 50
// 60

// ### ⚠️ 주의 사항

// 1. '배열의 구조를 정확히 이해해야 합니다.'
    
//    - 중첩 배열은 구조에 따라 반복문의 층수가 달라집니다. 반복문을 작성하기 전, 배열이 몇 단계로 중첩되어 있는지 먼저 파악해 보세요.
    
// 2. '인덱스 범위를 초과하지 않도록 주의하세요.'
    
//    - `arr[i][j]`처럼 중첩된 배열에 접근할 때, `i`나 `j`가 유효한 인덱스인지 항상 확인해야 합니다.
//     배열의 길이를 기준으로 조건을 정확히 설정해 주세요.
    
// 3. '불균형한 배열 구조에 유의하세요.'
    
//    - 모든 내부 배열이 동일한 길이를 갖고 있다고 가정하면 안 됩니다. 실제로는 내부 배열마다 길이가 다를 수 있으니, 각 배열의 `.length`를 따로 확인하는 것이 안전합니다.

// * check
// **중첩 배열(2차원 배열)**은 여러 개의 배열이 하나의 배열 안에 포함된 구조로, **행과 열** 형태의 데이터를 표현할 때 매우 유용합니다. 이번 시간에는 중첩 배열의 각 요소에 접근하기 위해 **중첩된 반복문**을 어떻게 사용하는지 살펴보았습니다.
// 바깥쪽 반복문이 **행(row)**을, 안쪽 반복문이 **열(column)**을 순회한다는 구조를 이해하면, 
// **표 형태의 데이터 처리**, **2차원 게임 보드 구성, 좌석 배치 출력** 등 다양한 상황에 쉽게 적용할 수 있습니다.


// ========================실습========================================
// 1. 주어진 seats 배열을 직접 사용하여 코드를 작성하세요.
// 2. 다중 반복문을 사용하여 모든 좌석 정보를 순회하세요.
// 3. 각 좌석의 상태가 '비어있음'인지 확인하세요.
// 4. 만약 좌석이 '비어있음' 상태라면, 해당 좌석의 이름을 console.log를 사용하여 출력하세요

// 좌석 상태 배열
const seats3 = [
  [
    ['A1', '예약됨'],
    ['A2', '비어있음'],
    ['A3', '비어있음'],
  ],
  [
    ['B1', '비어있음'],
    ['B2', '예약됨'],
    ['B3', '비어있음'],
  ],
  [
    ['C1', '예약됨'],
    ['C2', '예약됨'],
    ['C3', '비어있음'],
  ],
];

// 여기에 코드를 작성하세요
for (let i = 0; i < seats3.length; i++) {
    for (let j = 0; j < seats3[i].length; j++) {
        let seatName = seats3[i][j][0];
        let status = seats3[i][j][1];

        if (status === '비어있음') {
            console.log(`비어있는 좌석 : ${seatName}`);
        }
    }
}
